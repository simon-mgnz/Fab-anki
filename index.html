<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Fab'Anki ‚Äî Flashcards sans compte</title>
  <!-- KaTeX CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <!-- Firebase (compat) - add your project config in the firebaseConfig object below -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script>
    // Replace with your Firebase project's config. Leave as {} to disable cloud sync.
    window.__fabanki_firebaseConfig = window.__fabanki_firebaseConfig || {
        apiKey: "AIzaSyCHt0J--9GuXCE5PaU2vkdWVWTWRu5phBM",
        authDomain: "fab-anki-classement.firebaseapp.com",
        projectId: "fab-anki-classement",
        storageBucket: "fab-anki-classement.firebasestorage.app",
        messagingSenderId: "469715316592",
        appId: "1:469715316592:web:c737c247abed9199e0a9b5"
    };
    // initialize firebase if config provided
    (function(){
      try{
        const cfg = window.__fabanki_firebaseConfig || {};
        if(cfg && cfg.apiKey){
          firebase.initializeApp(cfg);
          window.__fabanki_firestore = firebase.firestore();
        } else { window.__fabanki_firestore = null; }
      }catch(e){ console.warn('Firebase init failed', e); window.__fabanki_firestore = null; }
    })();
  </script>
<style>
    :root{--bg:#f6f7fb;--fg:#111;--card:#fff;--muted:#666;--accent:#0066ff}
    [data-theme='dark']{--bg:#0f1115;--fg:#e6eef8;--card:#111319;--muted:#9aa4b2;--accent:#66a0ff}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .app{max-width:900px;margin:18px auto;padding:18px}
    header{display:flex;gap:8px;align-items:center;justify-content:space-between}
    h1{font-size:1rem;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    .deck-input{width:420px;max-width:40vw}
    .card{background:var(--card);border-radius:10px;padding:20px;box-shadow:0 6px 20px rgba(2,6,23,0.08);min-height:220px;display:flex;flex-direction:column;gap:12px}
    .card-content{flex:1;overflow:auto}
    .meta{font-size:0.9rem;color:var(--muted)}
    .buttons{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:transparent;color:var(--fg);border:1px solid rgba(0,0,0,0.06)}
    .resp-buttons{display:flex;gap:8px}
    .resp-buttons button{flex:1}
    .progress{height:8px;background:linear-gradient(90deg,#e6eef8 0%,#e6eef8 100%);border-radius:8px;overflow:hidden}
    .progress > i{display:block;height:100%;background:var(--accent);width:0%}
    .small{font-size:0.9rem}
    .muted{color:var(--muted)}
    footer{margin-top:12px;display:flex;justify-content:space-between;gap:8px;align-items:center}
    @media (max-width:640px){.deck-input{width:100%}}
    /* Make KaTeX output wrap responsively instead of forcing no-wrap */
    .katex{white-space:normal;word-break:break-word;overflow-wrap:anywhere}
    .katex .katex-html{white-space:normal}
    .katex .katex-mathml{white-space:normal}
    .katex-display{display:block; margin:0.6em 0}
    /* Dark theme detailed overrides */
    [data-theme='dark'] body{background:var(--bg);color:var(--fg)}
    [data-theme='dark'] .card{background:var(--card);color:var(--fg);box-shadow:0 6px 24px rgba(0,0,0,0.6)}
    [data-theme='dark'] header, [data-theme='dark'] footer{color:var(--muted)}
    [data-theme='dark'] input.deck-input{background:#0f1115;border:1px solid rgba(255,255,255,0.06);color:var(--fg)}
    [data-theme='dark'] button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--fg)}
    [data-theme='dark'] .muted{color:var(--muted)}
    [data-theme='dark'] .progress{background:#1b1d22}
    [data-theme='dark'] .progress > i{background:linear-gradient(90deg,#6f8cff,#b9bfff)}
    [data-theme='dark'] .hist-hint-box{background:#2b1a1a;border-left:4px solid #ff6b6b;color:#ffdede}
    /* Rating button colors (override in dark) */
    .rate-ratte{background:#d9534f}
    .rate-difficile{background:#f0ad4e}
    .rate-bon{background:#007bff}
    .rate-facile{background:#28a745}
    .card{
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
}


    /* Histogram styles */
    .histogram{display:flex;gap:12px;margin-top:18px;align-items:flex-end}
    .hist-column{flex:1;display:flex;flex-direction:column;align-items:center}
    .hist-count{font-weight:600;margin-bottom:6px;color:var(--muted)}
    .hist-viewport{width:100%;height:120px;background:transparent;display:flex;align-items:flex-end;justify-content:center}
    .hist-fill{width:70%;border-radius:6px 6px 0 0;box-shadow:inset 0 -4px 8px rgba(0,0,0,0.06)}
    .hist-label{font-size:0.85rem;margin-top:8px;text-align:center;color:var(--muted)}
    .hist-count{width:100%;text-align:center}

    /* Deck browser modal */
    .modal-overlay{position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0.4);display:none;align-items:flex-start;padding:48px;z-index:1000}
    .modal{background:var(--card);color:var(--fg);border-radius:12px;max-width:900px;width:100%;margin:0 auto;padding:12px;box-shadow:0 10px 40px rgba(0,0,0,0.25);}
    .modal{transform:translateY(-6px) scale(0.99);opacity:0;transition:transform .18s ease,opacity .18s ease}
    .modal.open{transform:translateY(0) scale(1);opacity:1}
    .tooltip{position:fixed;background:var(--card);color:var(--fg);padding:8px 10px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.12);font-size:0.9rem;z-index:1100}
    .modal h3{margin:6px 0}
    .deck-list{max-height:60vh;overflow:auto;padding:6px}
    .deck-entry{padding:8px;border-radius:8px;display:flex;justify-content:space-between;align-items:center}
    .deck-entry:hover{background:rgba(0,0,0,0.03)}

    /* Mobile full-screen card and swipe-to-show histogram */
    @media (max-width:640px){
      body,html{height:100%;overflow:hidden}
      .app{max-width:100%;margin:0;padding:0;padding-top:66px;padding-left:12px;padding-right:12px}
      header{position:fixed;top:0;left:0;right:0;height:56px;padding:0 8px;display:flex;align-items:center;justify-content:space-around;background:var(--card);box-shadow:0 6px 18px rgba(0,0,0,0.08);z-index:60}
      h1{font-size:1rem;margin:0;text-align:center}
      /* reduce height slightly so bottom buttons can appear above fold
        Use --vh to account for iOS dynamic toolbar (fix iOS 17+ where 100vh is unreliable) */
      .card{border-radius:0;min-height:calc(var(--vh,1vh) * 100 - 120px);padding:12px;display:flex;flex-direction:column;max-width:calc(100% - 24px);margin:0 auto}
      section#stats{display:none}
      section#stats.visible{display:block;position:fixed;left:0;right:0;top:0;bottom:0;padding:12px;z-index:999;overflow:auto}
      .hist-viewport{height:140px}
      .hist-fill{width:40%}
      .hist-count{width:100%;text-align:center}
      /* Larger, centered card text and buttons */
      /* center main content both horizontally and vertically */
      .card-content{display:flex;align-items:center;justify-content:center;text-align:center;font-size:1.05rem;padding:12px 6px 6px 6px;min-height:40vh}
      /* keep response buttons on a single line and compact */
      .resp-buttons{flex-wrap:nowrap;gap:6px;overflow:auto}
      .resp-buttons button{flex:0 1 auto;padding:8px 8px;font-size:0.92rem;min-width:56px}
      .buttons button{font-size:1.0rem;padding:8px 12px}
      /* make passer smaller on mobile so it doesn't force layout */
      .resp-buttons #passer{min-width:56px;padding:8px 8px;font-size:0.9rem}
    }
    /* Rating button colors */
    .rate-ratte{background:#d9534f}
    .rate-difficile{background:#f0ad4e}
    .rate-bon{background:#007bff}
    .rate-facile{background:#28a745}
    /* Passer button: outlined, keep to the right of easy and don't flex-grow */
    .resp-buttons #passer{flex:0 0 auto;min-width:84px;padding:10px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);background:transparent;color:var(--fg)}
    /* Hide histogram toggle on desktop; show only on mobile */
    #toggleStats{display:none}
    /* Close button for mobile stats (hidden by default) */
    #closeStatsMobile{display:none}
    /* Desktop uniform button/card sizes */
    @media (min-width:641px){
      .buttons button, .resp-buttons button, button.secondary{min-width:120px;padding:10px 14px}
      /* Standardize top-bar buttons on desktop */
      header .controls button{min-width:120px;padding:10px 14px}
      .card{min-height:260px}
      /* Disable page scrolling on desktop */
      body{overflow:hidden}
    }

    /* Center front content on desktop */
    @media (min-width:641px){
      .card-content > #front{display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center}
    }
    /* Mobile-specific rules */
    @media (max-width:640px){
      #toggleStats{display:inline-block}
      #closeStatsMobile{display:inline-block}
      /* Histogram vertical layout on mobile */
      .histogram{flex-direction:column;align-items:stretch}
      .hist-column{flex-direction:row;align-items:center;justify-content:space-between;padding:8px 6px}
      .hist-viewport{width:60%;height:24px}
      .hist-fill{height:100%;width:0%;border-radius:6px}
      .hist-count{width:30%;text-align:left;margin-right:6px}
      .hist-label{width:40%;text-align:right}
      /* Footer stacked vertically on mobile */
      footer{flex-direction:column;align-items:center;gap:6px}
    }
    /* Make deck browser modal full-screen on mobile like the stats overlay */
    @media (max-width:640px){
      .modal-overlay{padding:0;align-items:flex-start}
      .modal-overlay[aria-hidden="false"]{display:flex}
      .modal{border-radius:0;max-width:100%;height:100vh;width:100%;margin:0;padding:12px;padding-top:66px;box-shadow:none;overflow:auto}
      .modal .secondary{min-width:96px}
      /* Make Charger buttons gray; keep primary actions visually accentuated where needed */
      .modal .deck-entry button{margin-left:6px}
    }

    /* deck browser: due badge - big number with small label */
    /* due-badge: make available globally (welcome + deck browser) */
    .due-badge{color:#d9534f;font-weight:600;margin-left:8px;font-size:0.95rem;display:inline-block;text-align:center}
    .due-badge .due-num{font-size:1.25rem;font-weight:700;line-height:1}
    .due-badge .due-label{font-size:0.75rem;color:var(--muted)}
    .due-badge{margin-right:8px}
    .deck-entry .due-badge{margin-left:0}

    /* Level ring in profile popup */
    .level-box{display:flex;gap:12px;align-items:center;margin-top:10px}
    .level-ring{width:88px;height:88px;position:relative;flex:0 0 88px}
    .level-ring svg{width:100%;height:100%;transform:rotate(-90deg)}
    .level-ring .level-num{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:1.2rem}
    .level-info{display:flex;flex-direction:column}
    .level-info .next{font-size:0.9rem;color:var(--muted)}
    .level-info .progress-remaining{font-weight:700}
    /* Compact level summary card used on welcome page */
    .level-summary{max-width:720px;margin:0 auto 12px;padding:12px;display:flex;align-items:center;gap:12px;min-height:0 !important}
    .level-summary .level-ring{width:64px;height:64px;flex:0 0 64px}
    .level-summary .level-num{font-size:1.1rem}
    @media (max-width:640px){
      .level-summary{padding:10px;margin-bottom:10px}
      .level-summary .level-ring{width:56px;height:56px;flex:0 0 56px}
      .level-summary .level-num{font-size:1rem}
    }
    .deck-entry .deck-actions{display:flex;gap:8px;align-items:center}
    /* Footer full-bleed on desktop: make it span viewport width */
    @media (min-width:641px){
      footer{position:relative;left:50%;right:50%;margin-left:-50vw;margin-right:-50vw;width:100vw;padding:12px 18px}
    }
    /* Center card on desktop */
    @media (min-width:641px){
      main > div { display:flex; justify-content:center; }
      .card{max-width:760px;margin-left:auto;margin-right:auto}
    }
    /* TTS play button */
    .tts-play{margin-left:8px;padding:6px 8px;border-radius:8px;border:0;background:rgba(0,0,0,0.06);cursor:pointer}
    .tts-play:active{transform:scale(0.98)}
    /* Card status small box (persistent) */
    .card-status{position:absolute;left:14px;top:14px;padding:6px 10px;border-radius:8px;font-weight:600;z-index:1400;background:rgba(0,0,0,0.04);color:var(--fg)}
    /* Use same colors as histogram bars */
    .card-status.status-new{background:linear-gradient(180deg,#e9d8ff,#d6b8ff);color:#6f2fff}
    .card-status.status-now{background:rgba(217,83,79,0.12);color:#d9534f}
    .card-status.status-12h{background:rgba(255,155,155,0.12);color:#ff6b6b}
    .card-status.status-tomorrow{background:rgba(255,217,102,0.12);color:#b88600}
    .card-status.status-week{background:rgba(111,140,255,0.12);color:#2f6fff}
    .card-status.status-long{background:rgba(40,167,69,0.12);color:#1f7a2f}
    .card-status.status-upcoming{background:rgba(0,0,0,0.04);color:var(--muted)}

    /* XP toast animation */
    .xp-toast{animation:xp-pop .45s ease both}
    @keyframes xp-pop{0%{transform:translateY(-6px) scale(.92);opacity:0}50%{transform:translateY(-2px) scale(1.03);opacity:1}100%{transform:translateY(0) scale(1);opacity:1}}

    /* Level ring transitions */
    .level-ring .ring-fill{transition:stroke-dashoffset .9s cubic-bezier(.2,.9,.2,1), stroke .4s ease}
    /* Level up notification: animate in/out */
    .level-up-notify{position:fixed;left:50%;top:20%;transform:translateX(-50%) scale(.98);background:var(--card);padding:14px 18px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.2);z-index:2000;opacity:0;transform-origin:center center;transition:opacity .32s ease,transform .32s ease}
    .level-up-notify.show{opacity:1;transform:translateX(-50%) scale(1)}
    @keyframes level-up-in{0%{opacity:0;transform:translateX(-50%) scale(.9)}60%{opacity:1;transform:translateX(-50%) scale(1.05)}100%{opacity:1;transform:translateX(-50%) scale(1)} }
    /* XP toast animations */
    .xp-toast{opacity:0;transform:translateY(-6px) scale(.98);transition:opacity .28s ease,transform .28s cubic-bezier(.2,.9,.2,1);border-radius:8px;padding:6px 10px;font-weight:600;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
    .xp-toast.show{opacity:1;transform:translateY(0) scale(1)}
    .xp-toast.leave{opacity:0;transform:translateY(-8px) scale(.98)}
    /* Modal overlay fade when opened */
    .modal-overlay{opacity:0;transition:opacity .18s ease}
    .modal-overlay.open{opacity:1}
    .modal-overlay[aria-hidden="false"]{opacity:1}
    /* Hint box styling (red) */
    .hist-hint-box{background:#ffecec;border-left:4px solid #d9534f;color:#681214;padding:8px;border-radius:6px}
    @media (max-width:640px){
      /* On mobile, pin hint under top bar */
      .hist-hint-box{position:fixed;top:66px;left:12px;right:12px;z-index:1001;margin-top:0}
      /* Mobile modal & deck browser adjustments: remove unexpected left gutter, keep full-bleed */
      .modal-overlay{padding:0;left:0;right:0}
      .modal{box-sizing:border-box;padding-left:12px;padding-right:12px;margin-left:0 !important;margin-right:0 !important;left:0;right:0}
      .deck-list{padding-left:6px;padding-right:6px}
      .deck-entry{padding-left:6px;padding-right:6px}
      /* Ensure back element is centered like front on mobile */
      #back{display:none}
      .card-content #back{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:12px 6px 6px 6px;box-sizing:border-box;width:100%}
      /* Ensure all nested field content centers within the back element (mobile only) and respects card padding */
      .card-content #back .field{width:100%;max-width:760px;text-align:center;margin-left:auto;margin-right:auto}
      .card-content #back .field *{text-align:center}
      /* Remove left margin on due-badges on mobile to prevent odd gutter next to Charger */
      .deck-entry .due-badge{margin-left:0;margin-right:6px}
      /* Ensure both front and back occupy the .card-content flex space and center their content */
      .card-content > #front, .card-content > #back { width:100%; display:flex; flex:1 1 auto; flex-direction:column; align-items:center; justify-content:center }
    }
    /* Tight mobile tweaks for very narrow screens to prevent button overflow */
    @media (max-width:500px){
      .progress-container{flex:0 0 110px;min-width:90px;max-width:140px}
      .buttons{flex:1 1 auto;min-width:0}
      .resp-buttons{flex-wrap:wrap;gap:6px}
      .resp-buttons button{min-width:48px;padding:6px 8px;font-size:0.86rem}
      .buttons button{font-size:0.95rem;padding:8px 10px}
      .progress{height:6px}
      /* ensure progress container aligns at the right without being pushed off-screen */
      .progress-container{display:flex;flex-direction:column;align-items:flex-end;gap:6px}
      /* When buttons wrap, center both rows to align with each other */
      .buttons{justify-content:center; top: 12px}
      .resp-buttons{justify-content:center}
     }
    /* Leaderboard table styles */
    .leaderboard-table th{background:var(--card);text-align:left;padding:8px;border-bottom:1px solid rgba(0,0,0,0.06);font-weight:700}
    .leaderboard-table td{padding:8px;border-bottom:1px solid rgba(0,0,0,0.04)}
    .leaderboard-table tr:nth-child(even){background:rgba(0,0,0,0.02)}
    .badge-chip{background:rgba(0,0,0,0.04);padding:4px 6px;border-radius:6px;font-size:0.8rem}
     /* Small helper for popup open animation (profile uses .open class on modal and .open on overlay)
       showProfilePopup now toggles overlay.open when inserting the modal */
  </style>
</head>
<body>
  <div class="app" id="app" data-theme="light">
    <header>
      <h1 id="appTitle">Fab'Anki ‚Äî Flashcards (sans compte)</h1>
      <div class="controls">
        <!-- Hidden file picker used as a fallback when running the page from file:// -->
        <input id="filePicker" type="file" accept=".xml,application/xml" style="display:none" />
        <!-- swapped: Parcourir decks before Charger per user request -->
        <button id="browseDecks" data-label-text="Parcourir decks" data-label-emoji="üìö">Parcourir decks</button>
        <button id="profileBtn" data-label-text="Profile" data-label-emoji="üë§">Profile</button>
        <button id="loadBtn" class="secondary" data-label-text="Charger" data-label-emoji="üìÇ">Charger</button>
        <button id="toggleStats" class="secondary" data-label-text="Histogramme" data-label-emoji="üìä">Histogramme</button>
        <button id="toggleTheme" class="secondary" data-label-text="Mode sombre" data-label-emoji="üåô">Mode sombre</button>
        <button id="resetBtn" class="secondary" data-label-text="R√©initialiser donn√©es locales" data-label-emoji="‚ôªÔ∏è">R√©initialiser donn√©es locales</button>
      </div>
    </header>

    <main style="margin-top:12px">
      <div id="status" class="muted small">Fournissez l'URL d'un deck via le param√®tre <code>?deck=</code></div>

      <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
        <div style="flex:1">
          <div class="card" id="cardArea" aria-live="polite" style="position: relative;">
            <div class="card-content">
              <div id="front" class="front"></div>
              <div id="back" class="back" style="display:none"></div>
              <div id="always" class="muted small" style="margin-top:8px"></div>
            </div>

            <div class="buttons answer-bar">
              <button id="showAnswer">Afficher la r√©ponse</button>

              <div class="resp-buttons" id="respButtons" style="display:none">
                <button id="again" class="rate-ratte">Rat√©</button>
                <button id="hard" class="rate-difficile">Difficile</button>
                <button id="good" class="rate-bon">Bon</button>
                <button id="easy" class="rate-facile">Facile</button>
                <button id="passer" class="secondary">Passer</button>
              </div>
            </div>

            <!-- Progress bar reste en bas -->
            <div style="display:flex; gap:8px; align-items:flex-start; justify-content:space-between; margin-top: auto;">
              <div class="progress-container">
                <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
                <div id="progressInfo" class="muted small" style="text-align:center;margin-top:6px">R√©vis√©es : 0 / 0</div>
              </div>
            </div>
          </div>
          </div>
        </div>
        <!-- right panel removed: merged into main card -->
      </div>
    </main>

    <!-- Deck browser modal (hidden) -->
    <div id="deckBrowserOverlay" class="modal-overlay" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h3>Parcourir les decks (./decks/)</h3>
          <div>
            <button id="refreshDeckList" class="secondary">Rafra√Æchir</button>
            <button id="closeDeckBrowser" class="secondary">Fermer</button>
          </div>
        </div>
        <div id="deckBrowserMsg" class="muted small" style="margin-bottom:8px">Recherche de ./decks/ ...</div>
        <div id="deckList" class="deck-list"></div>
      </div>
    </div>

    <!-- Histogram / study breakdown -->
    <section id="stats" style="max-width:900px;margin:18px auto;padding:0 18px">
      <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:6px 0;color:var(--muted)">R√©partition des cartes par √©ch√©ance</h3>
        <button id="closeStatsMobile" class="secondary">‚úñÔ∏è</button>
      </div>
      <div id="histogram" class="histogram" aria-hidden="false">
        <div class="hist-column">
          <div id="count-new" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-new" style="background:linear-gradient(180deg,#e9d8ff,#d6b8ff)"></div></div>
          <div class="hist-label">Nouveau</div>
        </div>
        <div class="hist-column">
          <div id="count-now" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-now" style="background:#d9534f"></div></div>
          <div class="hist-label">Maintenant</div>
        </div>
        <div class="hist-column">
          <div id="count-12h" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-12h" style="background:#ff9b9b"></div></div>
          <div class="hist-label">&lt;12h</div>
        </div>
        <div class="hist-column">
          <div id="count-tomorrow" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-tomorrow" style="background:#ffd966"></div></div>
          <div class="hist-label">Demain</div>
        </div>
        <div class="hist-column">
          <div id="count-week" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-week" style="background:#6f8cff"></div></div>
          <div class="hist-label">&lt;1 semaine</div>
        </div>
        <div class="hist-column">
          <div id="count-long" class="hist-count">0</div>
          <div class="hist-viewport"><div class="hist-fill" id="bar-long" style="background:#28a745"></div></div>
          <div class="hist-label">Longtemps</div>
        </div>
      </div>
    </section>
    <!-- Hint box (kept OUTSIDE the stats section). On desktop it will appear under the chart; on mobile it's positioned above the main card via CSS. -->
    <div id="histHint" class="muted small hist-hint-box" style="margin-top:10px">Nouvelle version : Leaderboard, Titres, streak, plus de niveaux, meilleure review.</div>

    <footer>
      <div class="muted small" id="deckInfo"></div>
      <div class="muted small">Fab'Anki ‚Äî Fonctionne enti√®rement c√¥t√© navigateur</div>
      <div class="muted small">¬© Swiess corporation - 2026 - MPSI1 &gt;&gt; MPSI2</div>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>

  <script>
  // Single-file app implementing requested functions.

  // Utility: simple DOM helpers
  const $ = sel => document.querySelector(sel);

  // Application state
  let deckURL = null;
  let deck = {title:'', cards:[]};
  let dueCards = [];
  let currentIndex = 0;
  let sessionTotal = 0;
  let reviewedCount = 0;
  let deckKey = null; // prefix for localStorage
  let tooltipShown = false;
  let cardShownAt = Date.now();

  // === FSRS storage key helpers ===
  function storageKey(s){ return `fabanki:${deckKey}:${s}` }

  // Ensure incLocal is defined early (fallback) to avoid ReferenceError
  if(typeof incLocal !== 'function'){
    var incLocal = function(key, n){ try{ const v = Number(localStorage.getItem(key) || 0) + (n||1); localStorage.setItem(key, String(v)); return v; }catch(e){ return 0 } };
    try{ window.incLocal = incLocal; }catch(e){}
  }

  // Fix iOS 100vh issues: set CSS variable --vh using visualViewport / innerHeight
  function updateVh(){
    try{
      const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
      document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
    }catch(e){}
  }
  // update on relevant events
  try{ updateVh(); window.addEventListener('resize', updateVh); window.addEventListener('orientationchange', updateVh); if(window.visualViewport){ window.visualViewport.addEventListener('resize', updateVh); window.visualViewport.addEventListener('scroll', updateVh); } }catch(e){}

  // === Function: loadDeckFromURL ===
  async function loadDeckFromURL(url){
    updateStatus('T√©l√©chargement du deck...');
    try{
      const res = await fetch(url);
      if(!res.ok) throw new Error('HTTP '+res.status);
      const text = await res.text();
      const parser = new DOMParser();
      let xml = parser.parseFromString(text,'application/xml');
      let parsererror = xml.querySelector('parsererror');
      if(parsererror){
        // Fallback: some exported decks contain unescaped '<' inside TeX fields
        // which makes the file not well-formed XML. Try lenient HTML parsing.
        updateStatus('XML invalide ‚Äî tentative d\u00e9codage permissif (HTML)');
        xml = parser.parseFromString(text,'text/html');
        parsererror = null;
      }
      parseXMLDeck(xml, url);
      initFSRS();
      updateStatus('Deck charg√© ‚Äî pr√™t pour r√©vision');
    }catch(err){
      console.error(err);
      updateStatus('Erreur chargement deck: '+err.message);
      deck = {title:'', cards:[]};
      renderEmpty();
    }
  }

  // === Function: parseXMLDeck ===
  // Parse the <fields> definition (name,type,sides) and build per-card `fields` objects.
  // Rules implemented:
  // - Read field definitions from <fields> (order preserved) and store in deck.fieldDefs.
  // - For each <card>, build card.fields = { [fieldName]: { html, type, sides } }.
  // - If a field is absent in a <card>, it is omitted (robustness requirement).
  function parseXMLDeck(xml, url){
    // create a deckKey based on URL (use synchronous fallback hash to avoid Promise issues)
    deckKey = fallbackSha1(url).slice(0,10);
    deck = {title:'', cards:[], fieldDefs:[]};

    // title (optional)
    const titleEl = xml.querySelector('title') || xml.querySelector('name') || xml.documentElement.getAttribute('name');
    if(titleEl) deck.title = titleEl.textContent ? titleEl.textContent.trim() : (xml.documentElement.getAttribute('name')||'');

    // --- Read <fields> definitions ---
    // Each child of <fields> defines a field: tag name (rich-text|tex), @name and @sides.
    const fieldsContainer = xml.querySelector('fields');
    if(fieldsContainer){
      const defs = Array.from(fieldsContainer.children || []);
      for(const f of defs){
        // Use localName when available for robust tag detection
        const type = (f.localName || f.tagName || '').toLowerCase(); // e.g. 'rich-text' or 'tex'
        const name = f.getAttribute('name') || '';
        const sidesAttr = f.getAttribute('sides') || (f.textContent||'');
        const sides = interpretSides(sidesAttr);
        const lang = f.getAttribute('lang') || f.getAttribute('xml:lang') || '';
        if(name) deck.fieldDefs.push({name, type, sides, lang});
      }
    }

    // If no field definitions detected, fall back to old heuristic to keep backwards compatibility.
    if(deck.fieldDefs.length === 0){
      // Find any explicit field-like tags to infer names
      const inferred = Array.from(xml.querySelectorAll('rich-text,tex')).map(n=>({name:n.getAttribute('name')||'Front', type:n.tagName.toLowerCase(), sides:{front:true,back:false,always:false}}));
      deck.fieldDefs = inferred.length ? inferred : [{name:'Front', type:'rich-text', sides:{front:true,back:false,always:false}},{name:'Back', type:'rich-text', sides:{front:false,back:true,always:false}}];
    }

    // --- Build cards from <cards><card> ---
    // Prefer explicit <cards><card> nodes; fallback to any <card> elements anywhere
    const cardNodes = Array.from(xml.getElementsByTagName('card'));
    const candidates = cardNodes.length ? cardNodes : Array.from(xml.querySelectorAll('card, note, item, entry, record'));

    let idx = 0;
    for(const node of candidates){
      try{
        const cardObj = { id: node.getAttribute('id') || node.getAttribute('guid') || ('card-'+(idx++)), fields: {} };

        // For each fieldDef, attempt to read the corresponding element inside this <card>
        for(const def of deck.fieldDefs){
          let el = null;
          // 1) any child element with attribute name equal to field name
          el = Array.from(node.children).find(ch => (ch.getAttribute && ch.getAttribute('name') === def.name));
          // 2) any child element whose localName/tag matches the expected type and (optional) name
          if(!el) el = Array.from(node.children).find(ch => ((ch.localName || ch.tagName || '').toLowerCase() === def.type));
          // 3) fallback: any descendant with name attribute matching
          if(!el) el = node.querySelector(`[name="${def.name}"]`);
          // 4) last resort: first child element
          if(!el && node.children && node.children.length>0) el = node.children[0];

          if(el){
            // For <tts> fields, preserve textContent (treat like <p>) to avoid raw HTML parsing
            let html = '';
            if((def.type||'').toLowerCase() === 'tts'){
              html = (el.textContent || '').trim();
            } else {
              html = (el.innerHTML || '').trim();
            }
            const fldLang = el.getAttribute && (el.getAttribute('lang') || el.getAttribute('xml:lang')) || def.lang || '';
            cardObj.fields[def.name] = { html, type: def.type, sides: def.sides, lang: fldLang };
          }
        }

        // Only include card if it has at least one field
        if(Object.keys(cardObj.fields).length>0) deck.cards.push(cardObj);
        }catch(e){ console.warn('ignored malformed card', e); continue }
      }
    // If still empty, try to parse table rows as last fallback
    if(deck.cards.length===0){
      const rows = Array.from(xml.querySelectorAll('tr'));
      for(const r of rows){
        const tds = Array.from(r.querySelectorAll('td'));
        if(tds.length>=2){
          const cardObj = { id: 'card-'+(idx++), fields: {} };
          cardObj.fields['Front'] = { html: tds[0].innerHTML||'', type: 'rich-text', sides: {front:true,back:false,always:false} };
          cardObj.fields['Back']  = { html: tds[1].innerHTML||'', type: 'rich-text', sides: {front:false,back:true,always:false} };
          deck.cards.push(cardObj);
        }
      }
    }

    if(deck.cards.length===0) throw new Error('Aucune carte d√©tect√©e dans le fichier XML');

    // Update UI
    $('#deckInfo').textContent = `Deck: ${deck.title || 'non nomm√©'} ‚Äî ${deck.cards.length} cartes`;
  }

  // === Function: interpretSides ===
  // Accepts strings like "11","10","01", or words 'front','back','both','always'.
  function interpretSides(s){
    const out = {front:false, back:false, always:false};
    if(!s) { out.front=true; out.back=false; return out; }
    s = String(s).trim().toLowerCase();
    if(s==='both' || s==='11' || s==='always') { out.front=true; out.back=true; out.always=true; return out; }
    if(s==='front' || s==='f' || s==='10') { out.front=true; out.back=false; return out; }
    if(s==='back' || s==='b' || s==='01') { out.front=false; out.back=true; return out; }
    if(s.length===2 && /[01]{2}/.test(s)){ out.front = s[0]==='1'; out.back = s[1]==='1'; out.always = out.front && out.back; return out; }
    // fallback: show on front
    out.front=true; return out;
  }

  // === Function: renderFront ===
  // Render fields that are allowed on the front side according to their `sides`.
  // Each card now has `card.fields` where keys are field names and values are {html,type,sides}.
  function renderFront(card){
    const frontEl = $('#front');
    const alwaysEl = $('#always');
    if(!card) { frontEl.innerHTML=''; alwaysEl.textContent=''; return }

    // Clear previous content
    frontEl.innerHTML = '';
    alwaysEl.textContent = '';

    // Build front content following the order in deck.fieldDefs (if present)
    const defs = deck.fieldDefs || [];
    let anyAlways = false;
    for(const def of defs){
      const f = card.fields && card.fields[def.name];
      if(!f) continue;
      if(f.sides.always || f.sides.front){
        const node = buildFieldElement(def, f);
        frontEl.appendChild(node);
      }
      if(f.sides.always) anyAlways = true;
    }

    // Simple indicator if some fields are always visible on both sides
    // hide always-indicator (not shown per user preference)
    alwaysEl.textContent = '';
  }

  // === Function: renderBack ===
  // Similar to renderFront but shows fields allowed on the back side.
  function renderBack(card){
    const backEl = $('#back');
    if(!card){ backEl.innerHTML=''; return }

    backEl.innerHTML = '';
    const defs = deck.fieldDefs || [];
    let anyContent = false;
    // detect whether front is currently visible (so we avoid duplicating 'always' fields)
    const frontVisible = (function(){ try{ const fe = document.getElementById('front'); return fe && fe.style.display !== 'none'; }catch(e){ return false } })();
    for(const def of defs){
      const f = card.fields && card.fields[def.name];
      if(!f) continue;
      // If the field is visible on the front and the front is currently shown, skip it
      if(f.sides.front && frontVisible) continue;
      // Otherwise show fields that are marked for back (or 'always' when front is hidden)
      if(f.sides.back || (f.sides.always && !frontVisible)){
        const node = buildFieldElement(def, f);
        backEl.appendChild(node);
        anyContent = true;
      }
    }

    if(!anyContent){ backEl.innerHTML = '<em>Contenu masqu√© c√¥t√© r√©ponse</em>'; }
  }

  // Helper: buildFieldElement(def, f)
  // Returns an HTMLElement for a given field definition and card field value.
  function buildFieldElement(def, f){
    const wrapper = document.createElement('div');
    wrapper.className = 'field field-'+def.name.replace(/\s+/g,'-').toLowerCase();
    // Treat only explicit 'tex'/'math' types as TeX ‚Äî avoid matching 'text'
    const ttype = (f.type||def.type||'').toLowerCase();
    const isTexType = ['tex','math','latex'].includes(ttype);
    const isTTS = (ttype === 'tts');
    const isPlainText = (ttype === 'text');
    const containsBlockTags = /<(p|div|ul|ol|li|table|tr|td|br|h[1-6])\b/i.test(f.html||'');
    if(isTTS){
      // Render <tts> as a paragraph with plain text and add a play button
      const p = document.createElement('p');
      p.textContent = f.html || '';
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'tts-play secondary';
      btn.title = 'Lire le texte';
      btn.textContent = 'üîä';
      btn.addEventListener('click', ()=>{
        try{
          if(!('speechSynthesis' in window)){ alert('TTS non support√© dans ce navigateur'); return }
          // If currently speaking, cancel (acts as stop)
          if(window.speechSynthesis.speaking){ window.speechSynthesis.cancel(); btn.textContent = 'üîä'; return }
          const text = (f.html||'').trim();
          if(!text) return;
          const u = new SpeechSynthesisUtterance(text);
          // prefer English by default for TTS unless field specifies otherwise
          u.lang = 'en-US';
          // prefer default voice; user can modify in browser
          btn.textContent = '‚è∏';
          u.onend = ()=>{ try{ btn.textContent = 'üîä' }catch(e){} };
          u.onerror = ()=>{ try{ btn.textContent = 'üîä' }catch(e){} };
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(u);
        }catch(e){ console.warn('TTS error', e); alert('Erreur TTS: '+(e && e.message || e)); }
      });
      wrapper.appendChild(p);
      wrapper.appendChild(btn);
    } else if(isPlainText){
      // Render explicit <text> fields as plain text (do not attempt KaTeX)
      const p = document.createElement('p'); p.textContent = f.html || ''; wrapper.appendChild(p);
    } else if(isTexType && !containsBlockTags){
      // Safe to render with KaTeX (no block HTML inside)
      const texSrc = (f.html||'').trim();
      const span = document.createElement('div');
      try{
        if(window.katex && typeof katex.render === 'function'){
          const display = /\\\\\[|\\\\\]|\$\$|\n/.test(texSrc) || texSrc.split(/\\n|\n/).length>1;
          katex.render(texSrc, span, {throwOnError:false, displayMode: display});
        } else { span.textContent = texSrc }
      }catch(e){ span.textContent = texSrc }
      wrapper.appendChild(span);
    } else {
      // Render as HTML (rich-text) ‚Äî do NOT run KaTeX here
      wrapper.innerHTML = f.html || '';
    }
    return wrapper;
  }

  // === Function: renderKaTeX ===
  // Uses auto-render with throwOnError:false to avoid breaking on invalid TeX.
  function renderKaTeX(container){
    // No-op: we render only explicit <tex> fields using katex.render()
    return;
  }

  // === FSRS implementation (SM-2-like) ===
  function initFSRS(){
    // ensure per-card state exists
    for(const c of deck.cards){
      const key = storageKey('card:'+c.id);
      if(!localStorage.getItem(key)){
        const state = {reps:0,interval:0,ef:2.5,due: (new Date()).toISOString(), last: null};
        localStorage.setItem(key, JSON.stringify(state));
      }
    }
    dueCards = getDueCards();
    // sessionTotal should equal number of due cards at session start
    sessionTotal = dueCards.length; reviewedCount = 0;
    const dueEl = $('#dueCount'); if(dueEl) dueEl.textContent = dueCards.length;
    currentIndex = 0;
    showNextCard();
    updateProgressDisplay();
    updateHistogram();
  }

  function getDueCards(){
    // use current time so cards scheduled for now are included
    const now = new Date();
    const nowList = [], newList = [];
    for(const c of deck.cards){
      const key = storageKey('card:'+c.id);
      const st = JSON.parse(localStorage.getItem(key) || '{}');
      const due = st && st.due ? new Date(st.due) : new Date();
      const isNew = (!st || (!st.last && (st.reps===0 || st.reps===undefined)));
      if(due <= now && !isNew){ nowList.push(c); }
      else if(isNew){ newList.push(c); }
    }
    // shuffle within each bucket
    const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } };
    shuffle(nowList); shuffle(newList);
    // prioritize 'Maintenant' then 'Nouveau'
    return nowList.concat(newList);
  }

  // === Histogram helper ===
  function updateHistogram(){
    if(!deck || !deck.cards) return;
    const now = new Date();
    const counts = {new:0, now:0, h12:0, tomorrow:0, week:0, long:0};
    for(const c of deck.cards){
      const key = storageKey('card:'+c.id);
      const st = JSON.parse(localStorage.getItem(key) || '{}');
      if(!st || (!st.last && (st.reps===0 || st.reps===undefined))){ counts.new++; continue }
      const due = st && st.due ? new Date(st.due) : now;
      const hrs = (due - now) / (1000*60*60);
      if(due <= now) counts.now++;
      else if(hrs <= 12) counts.h12++;
      else if(hrs <= 24) counts.tomorrow++;
      else if(hrs <= 24*7) counts.week++;
      else counts.long++;
    }
    // compute max for scaling
    const max = Math.max(1, counts.new, counts.now, counts.h12, counts.tomorrow, counts.week, counts.long);
    // set fills heights and counts above bars
    const setCol = (fillId, countId, val) => {
      const fill = document.getElementById(fillId);
      const cnt = document.getElementById(countId);
      if(cnt) cnt.textContent = val;
      if(!fill) return;
      const pct = Math.round((val / max) * 100);
      if(window.innerWidth <= 640){
        // mobile: horizontal bars (width-based)
        fill.style.width = pct + '%';
        fill.style.height = '100%';
      } else {
        // desktop: vertical bars (height-based)
        fill.style.height = pct + '%';
        fill.style.width = '';
      }
      fill.title = val + ' cartes';
    };
    setCol('bar-new','count-new', counts.new);
    setCol('bar-now','count-now', counts.now);
    setCol('bar-12h','count-12h', counts.h12);
    setCol('bar-tomorrow','count-tomorrow', counts.tomorrow);
    setCol('bar-week','count-week', counts.week);
    setCol('bar-long','count-long', counts.long);
    // Also update session total display if it hasn't been set (fallback)
    const infoEl = document.getElementById('progressInfo');
    if(infoEl && sessionTotal === 0){ infoEl.textContent = `R√©vis√©es : ${reviewedCount} / ${sessionTotal}` }
  }

  function updateProgressDisplay(){
    const infoEl = document.getElementById('progressInfo');
    const pb = document.getElementById('progressBar');
    const total = sessionTotal || 0;
    const done = reviewedCount || 0;
    if(infoEl) infoEl.textContent = `R√©vis√©es : ${done} / ${total}`;
    if(pb){ const pct = total>0? Math.round((done/total)*100): 0; pb.style.width = pct + '%'; }
  }

  function scheduleCard(cardId, quality){
    // quality: 0..5 following SM-2 mapping. We'll expect mapping from buttons.
    const key = storageKey('card:'+cardId);
    const st = JSON.parse(localStorage.getItem(key) || '{}');
    const today = startOfDay(new Date());
    if(quality < 3){
      // Rat√©: reset and make due immediately
      st.reps = 0; st.interval = 0; // due now
    } else {
      // Conservative FSRS adjustments to better separate qualities:
      // - Hard (3): small bonus, penalize ef
      // - Good (4): normal behavior
      // - Easy (5): larger bonus and ensure first-success moves to >= tomorrow
      if(!st.reps) st.reps = 0;
      if(st.reps === 0){
        if(quality === 5) st.interval = 2; // Easy: at least 2 days on first success
        else if(quality === 4) st.interval = 1; // Good: tomorrow
        else st.interval = 1; // Hard: tomorrow but conservative
      } else if(st.reps === 1){
        if(quality === 5) st.interval = 8; // reward Easy with larger second interval
        else if(quality === 4) st.interval = 6; // standard
        else st.interval = 3; // Hard: limited bonus
      } else {
        const baseMult = (st.ef || 2.5);
        let mult = baseMult;
        if(quality === 3) mult = Math.max(1.1, baseMult * 0.8); // Hard -> conservative growth
        else if(quality === 4) mult = Math.max(1.15, baseMult * 0.95);
        else if(quality === 5) mult = baseMult * 1.2; // Easy -> larger growth
        st.interval = Math.max(1, Math.round(st.interval * mult));
      }
      st.reps = (st.reps || 0) + 1;
      // update ef but apply stronger penalties/bonuses depending on quality
      st.ef = (st.ef || 2.5) + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
      if(quality === 3) st.ef = (st.ef || 2.5) - 0.15; // penalize for Hard
      if(quality === 5) st.ef = (st.ef || 2.5) + 0.12; // boost for Easy
      if(st.ef < 1.3) st.ef = 1.3;
    }
    // set due
    let next;
    const prevDue = st && st.due ? new Date(st.due) : null;
    const now = new Date();
    if((st.interval || 0) === 0){
      next = new Date(); // immediate
    } else {
      next = addDays(today, st.interval || 1);
    }
    st.due = next.toISOString();
    st.last = (new Date()).toISOString();
    localStorage.setItem(key, JSON.stringify(st));
    // If this card moved from future to 'now' during the session, include it in session total
    try{
      if(prevDue && prevDue > now && next <= now){ sessionTotal = (sessionTotal||0) + 1; updateProgressDisplay(); }
    }catch(e){}
    // update due list and UI
    dueCards = getDueCards();
    const dueEl = $('#dueCount'); if(dueEl) dueEl.textContent = dueCards.length;
    updateHistogram();
  }

  // random integer helper
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1)) + min }

  // === Helpers ===
  // updateStatus: set status text and ensure on mobile the status appears above the hint box
    function updateStatus(t){
    try{
      const s = document.getElementById('status'); if(!s) return; s.textContent = t;
      const hint = document.getElementById('histHint');
      // Show status and hint in normal document flow above the main card (mobile and desktop).
      // Avoid using fixed positioning which overlays the card content.
      if(s){ s.style.position = ''; s.style.top = ''; s.style.left = ''; s.style.right = ''; s.style.zIndex = ''; s.style.background = ''; s.style.padding = t ? '8px' : ''; s.style.borderRadius = t ? '6px' : ''; s.style.boxShadow = t ? '0 6px 18px rgba(0,0,0,0.04)' : ''; s.style.display = t ? 'block' : ''; }
      if(hint){ hint.style.position = ''; hint.style.top = ''; hint.style.left = ''; hint.style.right = ''; hint.style.zIndex = ''; hint.style.display = t ? 'block' : ''; }
    }catch(e){ try{ $('#status').textContent = t }catch(e){} }
  }
  function renderEmpty(){
    const front = $('#front'); if(front) front.innerHTML='';
    const back = $('#back'); if(back) back.innerHTML='';
    const resp = $('#respButtons'); if(resp) resp.style.display='none';
    const sa = $('#showAnswer'); if(sa) sa.style.display='none';
  }
  function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x }
  function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x }

  // sha1 small implementation (for id generation). Use subtle crypto if available.
  function sha1(msg){
    try{
      const enc = new TextEncoder();
      const data = enc.encode(msg);
      return crypto.subtle.digest('SHA-1', data)
        .then(buf => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join(''))
        .catch(() => fallbackSha1(msg));
    }catch(e){
      return fallbackSha1(msg);
    }
  }

  function fallbackSha1(s){
    // crude fallback hash for environments without crypto.subtle
    let h = 0;
    for(let i=0;i<s.length;i++){
      h = ((h<<5)-h) + s.charCodeAt(i);
      h |= 0;
    }
    return (h>>>0).toString(16);
  }

  // Because crypto.subtle returns a Promise, wrap sha1 usage accordingly in parseXMLDeck id creation.
  // For simplicity where sha1 is used synchronously above, ensure fallback string is returned; this is acceptable for IDs.

  // === UI flow ===
  function showNextCard(){
    if(!dueCards || dueCards.length===0){ updateStatus('Aucune carte √† r√©viser aujourd\'hui'); renderEmpty(); return }
    if(currentIndex >= dueCards.length) currentIndex = 0;
    const c = dueCards[currentIndex];
    const sa = $('#showAnswer'); if(sa) sa.style.display = 'inline-block';
    const resp = $('#respButtons'); if(resp) resp.style.display = 'none';
    const backEl = $('#back'); if(backEl) backEl.style.display = 'none';
    renderFront(c);
    // update card status box (Nouveau / Maintenant)
    try{ renderCardStatus(c); }catch(e){}
    // record when this card was shown to compute XP based on time spent
    try{ cardShownAt = Date.now(); }catch(e){}
    // Ensure front is visible (might have been hidden after showing an answer)
    const frontEl = $('#front'); if(frontEl){ frontEl.style.display = 'flex'; frontEl.style.flex = '1 1 auto'; }
    // do not show per-card index (user requested removal)
    // progress
    const pct = Math.round(((currentIndex)/Math.max(1,dueCards.length))*100);
    const pb = $('#progressBar'); if(pb) pb.style.width = pct + '%';
  }

  // Render or update the small persistent card status box
  function renderCardStatus(card){
    try{
      if(!card) return;
      const cardArea = document.getElementById('cardArea'); if(!cardArea) return;
      let stEl = document.getElementById('cardStatus');
      if(!stEl){ stEl = document.createElement('div'); stEl.id = 'cardStatus'; stEl.className = 'card-status'; cardArea.appendChild(stEl); cardArea.style.position = cardArea.style.position || 'relative'; }
      const key = storageKey('card:'+card.id);
      const st = JSON.parse(localStorage.getItem(key) || '{}');
      const now = new Date();
      let txt = '';
      let cls = 'status-upcoming';
      const isNew = (!st || (!st.last && (st.reps===0 || st.reps===undefined)));
      if(isNew){ txt = 'Nouveau'; cls = 'status-new'; }
      else {
        const due = st && st.due ? new Date(st.due) : now;
        const hrs = (due - now) / (1000*60*60);
        if(due <= now){ txt = 'Maintenant'; cls = 'status-now'; }
        else if(hrs <= 12){ txt = '<12h'; cls = 'status-12h'; }
        else if(hrs <= 24){ txt = 'Demain'; cls = 'status-tomorrow'; }
        else if(hrs <= 24*7){ txt = '<1 sem'; cls = 'status-week'; }
        else { txt = 'Longtemps'; cls = 'status-long'; }
      }
      stEl.textContent = txt; stEl.className = 'card-status ' + cls;
    }catch(e){ console.warn('renderCardStatus', e) }
  }

  // Button handlers
    $('#showAnswer').addEventListener('click', ()=>{
    const c = dueCards[currentIndex];
    try{
      renderBack(c);
      const frontEl = $('#front');
      const backEl = $('#back');
      const respBtn = $('#respButtons');
      const showBtn = $('#showAnswer');
      if(window.innerWidth <= 640){
        // mobile: replace front with back (full-screen centered)
        if(frontEl){ frontEl.style.display = 'none'; frontEl.style.flex = '0 0 auto'; }
        if(backEl){ backEl.style.display = 'flex'; backEl.style.flex = '1 1 auto'; }
      } else {
        // desktop: show answer under the question, center both
        if(frontEl){ frontEl.style.display = 'block'; frontEl.style.flex = '0 0 auto'; }
        if(backEl){ backEl.style.display = 'block'; backEl.style.flex = '0 0 auto'; }
        // ensure text inside both is centered
        try{ frontEl.querySelectorAll('.field').forEach(n=>n.style.textAlign='center'); }catch(e){}
        try{ backEl.querySelectorAll('.field').forEach(n=>n.style.textAlign='center'); }catch(e){}
      }
      if(respBtn) respBtn.style.display = 'flex';
      if(showBtn) showBtn.style.display = 'none';
    }catch(e){ console.warn('showAnswer error', e); }
  });

  $('#again').addEventListener('click', ()=>{ answerCurrent(0) });
  $('#hard').addEventListener('click', ()=>{ answerCurrent(3) });
  $('#good').addEventListener('click', ()=>{ answerCurrent(4) });
  $('#easy').addEventListener('click', ()=>{ answerCurrent(5) });
  // Pass current card: mark as 'Never' (far future) and remove from session
  $('#passer').addEventListener('click', ()=>{ passCurrent() });

  function passCurrent(){
    try{
      const c = dueCards[currentIndex]; if(!c) return;
      // mark card as never due again by setting a far-future date
      const key = storageKey('card:'+c.id);
      const st = JSON.parse(localStorage.getItem(key) || '{}');
      st.never = true;
      st.due = new Date(9999,11,31,23,59,59).toISOString();
      st.last = (new Date()).toISOString();
      localStorage.setItem(key, JSON.stringify(st));
      // count this as reviewed for session
      reviewedCount = (reviewedCount || 0) + 1; updateProgressDisplay();
      try{ incLocal('fabanki:pass_total', 1); resetWeeklyIfNeeded(); resetMonthlyIfNeeded(); const delta = -6; const cur = Number(localStorage.getItem('fabanki:score_mpsi_semaine')||0)+delta; localStorage.setItem('fabanki:score_mpsi_semaine', String(cur)); const curM = Number(localStorage.getItem('fabanki:score_mpsi_mois')||0)+delta; localStorage.setItem('fabanki:score_mpsi_mois', String(curM)); }catch(e){}
      try{ incLocal('fabanki:cards_since_streak_reset',1); }catch(e){}
      // increment consecutive-without-pass counter (used for Noether)
      try{ localStorage.setItem('fabanki:consec_no_pass','0'); }catch(e){}
      try{ localStorage.setItem('fabanki:consec_correct','0'); localStorage.setItem('fabanki:consec_difficult','0'); }catch(e){}
      try{ const deltaToday = -6; const curD = Number(localStorage.getItem('fabanki:score_mpsi_today')||0) + deltaToday; localStorage.setItem('fabanki:score_mpsi_today', String(curD)); }catch(e){}
      // remove from due list and show next
      dueCards.splice(currentIndex, 1);
      if(currentIndex >= dueCards.length){ updateStatus('R√©vision termin√©e pour aujourd\'hui'); renderEmpty(); }
      else { showNextCard(); }
      const dueEl2 = $('#dueCount'); if(dueEl2) dueEl2.textContent = dueCards.length;
      updateHistogram();
      try{ if(typeof updateProfilePopupIfOpen === 'function') updateProfilePopupIfOpen(); }catch(e){}
      try{ if(typeof syncClassement === 'function') syncClassement(); }catch(e){}
      try{
        // apply penalty XP for pass action
        const section = (typeof window.getDeckSection === 'function') ? window.getDeckSection() : '';
        const pen = (typeof window.computePenaltyForSection === 'function') ? window.computePenaltyForSection(section) : (section? -2 : -2);
        const applied = (typeof window.applyXp === 'function') ? window.applyXp(pen) : 0;
        if(applied) { try{ window.showXpToast(applied); }catch(e){} }
        if(typeof updateProfilePopupIfOpen === 'function') updateProfilePopupIfOpen();
      }catch(e){}
    }catch(e){ console.warn('pass error', e); }
  }

  function answerCurrent(q){
    const c = dueCards[currentIndex];
    // count this attempt for session progress
    reviewedCount = (reviewedCount || 0) + 1;
    updateProgressDisplay();
    // capture previous review time (hours since last review) to compute XP multiplier
    let prevReviewHours = null;
    try{
      const keyPrev = storageKey('card:'+c.id);
      const stPrev = JSON.parse(localStorage.getItem(keyPrev) || '{}');
      if(stPrev && stPrev.last){ const lastD = new Date(stPrev.last); prevReviewHours = (new Date() - lastD) / (1000*60*60); }
      else if(stPrev && stPrev.due){ const pd = new Date(stPrev.due); prevReviewHours = (new Date() - pd) / (1000*60*60); }
    }catch(e){}
    scheduleCard(c.id, q);
    // update local counters for ranking
    // Robustly update local counters and titles metrics
    try{
      const keyPrev = storageKey('card:'+c.id);
      const stNow = JSON.parse(localStorage.getItem(keyPrev) || '{}');
      // mastered detection: became mastered if reps crossed threshold (>=3)
      try{
        const prevReps = (typeof stPrev !== 'undefined' && stPrev && stPrev.reps) ? Number(stPrev.reps) : 0;
        const nowReps = (stNow && stNow.reps) ? Number(stNow.reps) : 0;
        if(prevReps < 3 && nowReps >= 3){ incLocal('fabanki:mastered_total',1); }
      }catch(e){}

      try{ incLocal('fabanki:cards_since_streak_reset',1); }catch(e){}

      // compute time spent on card for Hadamard (long answers)
      let timeSec = 0;
      try{ timeSec = Math.max(0, (Date.now() - (cardShownAt||Date.now())) / 1000); }catch(e){}
      try{ if(timeSec > 20) incLocal('fabanki:long_answer_total', 1); }catch(e){}

      // quality handling
      if(q < 3){
        incLocal('fabanki:fail_total',1);
        try{ localStorage.setItem('fabanki:consec_difficult','0'); }catch(e){}
        try{ localStorage.setItem('fabanki:consec_correct','0'); }catch(e){}
        try{ localStorage.setItem('fabanki:consec_no_pass','0'); }catch(e){}
        try{ resetWeeklyIfNeeded(); resetMonthlyIfNeeded(); const delta = -4; localStorage.setItem('fabanki:score_mpsi_semaine', String(Number(localStorage.getItem('fabanki:score_mpsi_semaine')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_today', String(Number(localStorage.getItem('fabanki:score_mpsi_today')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_mois', String(Number(localStorage.getItem('fabanki:score_mpsi_mois')||0)+delta)); }catch(e){}
      } else if(q === 3){
        incLocal('fabanki:difficult_total',1);
        try{ const cd = incLocal('fabanki:consec_difficult',1); if(cd >= 100) localStorage.setItem('fabanki:objective_Feynman','1'); }catch(e){}
        try{ incLocal('fabanki:consec_correct',1); const consec = Number(localStorage.getItem('fabanki:consec_correct')||0); const maxi = Math.max(Number(localStorage.getItem('fabanki:consec_correct_max')||0), consec); localStorage.setItem('fabanki:consec_correct_max', String(maxi)); }catch(e){}
        try{ const cnp = incLocal('fabanki:consec_no_pass',1); const maxnp = Math.max(Number(localStorage.getItem('fabanki:consec_no_pass_max')||0), cnp); localStorage.setItem('fabanki:consec_no_pass_max', String(maxnp)); }catch(e){}
        try{ resetWeeklyIfNeeded(); resetMonthlyIfNeeded(); const delta = 1; localStorage.setItem('fabanki:score_mpsi_semaine', String(Number(localStorage.getItem('fabanki:score_mpsi_semaine')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_today', String(Number(localStorage.getItem('fabanki:score_mpsi_today')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_mois', String(Number(localStorage.getItem('fabanki:score_mpsi_mois')||0)+delta)); }catch(e){}
      } else if(q === 4){
        incLocal('fabanki:good_total',1);
        try{ localStorage.setItem('fabanki:consec_difficult','0'); }catch(e){}
        try{ incLocal('fabanki:consec_correct',1); const consec = Number(localStorage.getItem('fabanki:consec_correct')||0); const maxi = Math.max(Number(localStorage.getItem('fabanki:consec_correct_max')||0), consec); localStorage.setItem('fabanki:consec_correct_max', String(maxi)); }catch(e){}
        try{ const cnp = incLocal('fabanki:consec_no_pass',1); const maxnp = Math.max(Number(localStorage.getItem('fabanki:consec_no_pass_max')||0), cnp); localStorage.setItem('fabanki:consec_no_pass_max', String(maxnp)); }catch(e){}
        try{ resetWeeklyIfNeeded(); resetMonthlyIfNeeded(); const delta = 2; localStorage.setItem('fabanki:score_mpsi_semaine', String(Number(localStorage.getItem('fabanki:score_mpsi_semaine')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_today', String(Number(localStorage.getItem('fabanki:score_mpsi_today')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_mois', String(Number(localStorage.getItem('fabanki:score_mpsi_mois')||0)+delta)); }catch(e){}
      } else if(q === 5){
        incLocal('fabanki:good_total',1);
        try{ localStorage.setItem('fabanki:consec_difficult','0'); }catch(e){}
        try{ incLocal('fabanki:consec_correct',1); const consec = Number(localStorage.getItem('fabanki:consec_correct')||0); const maxi = Math.max(Number(localStorage.getItem('fabanki:consec_correct_max')||0), consec); localStorage.setItem('fabanki:consec_correct_max', String(maxi)); }catch(e){}
        try{ const cnp = incLocal('fabanki:consec_no_pass',1); const maxnp = Math.max(Number(localStorage.getItem('fabanki:consec_no_pass_max')||0), cnp); localStorage.setItem('fabanki:consec_no_pass_max', String(maxnp)); }catch(e){}
        try{ resetWeeklyIfNeeded(); resetMonthlyIfNeeded(); const delta = 3; localStorage.setItem('fabanki:score_mpsi_semaine', String(Number(localStorage.getItem('fabanki:score_mpsi_semaine')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_today', String(Number(localStorage.getItem('fabanki:score_mpsi_today')||0)+delta)); localStorage.setItem('fabanki:score_mpsi_mois', String(Number(localStorage.getItem('fabanki:score_mpsi_mois')||0)+delta)); }catch(e){}
      }
    }catch(e){ console.warn('answerCurrent counters', e) }
    // Anki-like behaviour: on Fail (q<3) reinsert this card later in the session
    if(q < 3){
      // remove current card from list
      dueCards.splice(currentIndex, 1);
      // insert it after a random offset (5..20)
      const offset = randInt(5,20);
      const insertPos = Math.min(dueCards.length, currentIndex + offset);
      dueCards.splice(insertPos, 0, c);
      // don't advance index: currentIndex now points to the next card
      if(dueCards.length === 0){ updateStatus('R√©vision termin√©e pour aujourd\'hui'); renderEmpty(); }
      else { showNextCard(); }
    } else {
      // remove answered card; next card naturally shifts into currentIndex
      dueCards.splice(currentIndex, 1);
      if(currentIndex >= dueCards.length){ updateStatus('R√©vision termin√©e pour aujourd\'hui'); renderEmpty(); }
      else { showNextCard(); }
    }
    const dueEl2 = $('#dueCount'); if(dueEl2) dueEl2.textContent = dueCards.length;
    updateProgressDisplay();
    try{
      // compute XP for this successful review (only for qualities 3/4/5)
      if([3,4,5].includes(q)){
        try{
          const timeSec = Math.max(0, (Date.now() - (cardShownAt||Date.now())) / 1000);
          // track long answers (>20s) for Hadamard titre
          try{ if(timeSec > 20) incLocal('fabanki:long_answer_total', 1); }catch(e){}
          const section = (typeof window.getDeckSection === 'function') ? window.getDeckSection() : '';
          const xp = (typeof window.computeXpForQuality === 'function') ? window.computeXpForQuality(section, q, timeSec, prevReviewHours) : 0;
          const applied = (typeof window.applyXp === 'function') ? window.applyXp(xp) : 0;
          if(applied) { try{ window.showXpToast(applied); }catch(e){} }
        }catch(e){ console.warn('xp calc', e); }
      }
      if(typeof updateProfilePopupIfOpen === 'function') updateProfilePopupIfOpen();
      try{ if(typeof syncClassement === 'function') syncClassement(); }catch(e){}
    }catch(e){}
  }

  // Load deck from URL param on start
  function param(key){ const p = new URLSearchParams(location.search); return p.get(key) }
  window.addEventListener('load', async ()=>{
  // wire UI
  try{ ensurePseudo(); resetWeeklyIfNeeded(); resetDailyIfNeeded(); }catch(e){}
    // Load button now opens file picker to add a local deck
    $('#loadBtn').addEventListener('click', ()=>{
      const picker = document.getElementById('filePicker');
      if(picker) { picker.value = ''; picker.click(); updateStatus('S√©lectionnez un fichier XML √† charger...') }
    });

    // Hidden file picker: read local XML and parse
    const filePicker = document.getElementById('filePicker');
    if(filePicker){
      filePicker.addEventListener('change', (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        const reader = new FileReader();
        reader.onload = (e)=>{
          try{
            const text = e.target.result;
            const parser = new DOMParser();
            let xml = parser.parseFromString(text,'application/xml');
            let parsererror = xml.querySelector('parsererror');
            if(parsererror){
              // Try lenient HTML parse as fallback for malformed XML (unescaped '<' in TeX)
              updateStatus('XML invalide ‚Äî utilisation d\u00e9codage permissif pour le fichier local');
              xml = parser.parseFromString(text,'text/html');
              parsererror = null;
            }
            parseXMLDeck(xml, f.name);
            initFSRS();
            updateStatus('Deck charg√© depuis fichier local');
            // set deckURL for consistency but do not try to write to ./decks/
            deckURL = './decks/'+f.name;
            history.replaceState(null,'', '?deck='+encodeURIComponent(f.name));
          }catch(err){ console.error(err); updateStatus('Erreur lecture du fichier local'); }
        };
        reader.readAsText(f);
      });
    }
    $('#resetBtn').addEventListener('click', ()=>{ if(confirm('Supprimer toutes les donn√©es locales pour ce deck ?')){ // clear keys for this deck
      if(!deckKey) { alert('Aucun deck charg√©'); return }
      const prefix = `fabanki:${deckKey}:`;
      for(const k of Object.keys(localStorage)) if(k.startsWith(prefix)) localStorage.removeItem(k);
      alert('Donn√©es locales supprim√©es'); initFSRS(); }});
    const toggleBtn = $('#toggleTheme');
    if(toggleBtn){
      // ensure document root inherits initial theme
      document.documentElement.setAttribute('data-theme', document.getElementById('app')?.getAttribute('data-theme') || 'light');
        toggleBtn.addEventListener('click', ()=>{
        const appEl = document.getElementById('app');
        if(!appEl) return;
        const current = document.documentElement.getAttribute('data-theme') || 'light';
        const t = current === 'light' ? 'dark' : 'light';
        // set on root so CSS variables apply globally, and on app for scoped selectors
        document.documentElement.setAttribute('data-theme', t);
        appEl.setAttribute('data-theme', t);
        const themeLabel = t==='dark' ? 'Mode clair' : 'Mode sombre';
        toggleBtn.setAttribute('data-label-text', themeLabel);
        try{ if(typeof updateTopBarLabels === 'function') updateTopBarLabels(); }catch(e){}
      });

    }

    // Update app title for mobile vs desktop (mobile shows short title)
    function updateAppTitle(){
      try{
        const el = document.getElementById('appTitle'); if(!el) return;
        if(window.innerWidth <= 640) el.textContent = "Fab'Anki";
        else el.textContent = "Fab'Anki ‚Äî Flashcards (sans compte)";
      }catch(e){}  
    }
    updateAppTitle();
    window.addEventListener('resize', updateAppTitle);
    // Ensure status/hint positions update on resize
    window.addEventListener('resize', ()=>{ try{ updateStatus(document.getElementById('status')?.textContent || '') }catch(e){} });

    // Move grading buttons into main card area so they appear with the card
    try{
      const resp = document.getElementById('respButtons');
      const mainButtons = document.querySelector('#cardArea .buttons');
      if(resp && mainButtons){
        mainButtons.appendChild(resp);
        resp.style.display = 'none';
        resp.style.marginTop = '8px';
      }
    }catch(e){ /* ignore */ }

    // Swipe gestures: disabled by default. Set `swipeEnabled = true` to re-enable.
    try{
      const swipeEnabled = false;
      let touchStartY = 0, touchStartX = 0, touching = false;
      const cardArea = document.getElementById('cardArea');
      const statsSection = document.getElementById('stats');
      if(swipeEnabled && cardArea && statsSection){
        cardArea.addEventListener('touchstart', (ev)=>{ if(window.innerWidth<=640){ const t = ev.touches[0]; touchStartY = t.clientY; touchStartX = t.clientX; touching = true } });
        cardArea.addEventListener('touchmove', (ev)=>{ if(!touching) return; const t = ev.touches[0]; const dy = t.clientY - touchStartY; const dx = t.clientX - touchStartX; if(dy > 80 && Math.abs(dy) > Math.abs(dx)){ statsSection.classList.add('visible'); touching = false } });
        // allow hiding with swipe up inside stats overlay
        statsSection.addEventListener('touchstart', (ev)=>{ if(window.innerWidth<=640){ const t = ev.touches[0]; touchStartY = t.clientY; touching = true } });
        statsSection.addEventListener('touchmove', (ev)=>{ if(!touching) return; const t = ev.touches[0]; const dy = t.clientY - touchStartY; if(dy < -80){ statsSection.classList.remove('visible'); touching = false } });
      }
    }catch(e){ /* ignore */ }

    // Wire Browse Decks modal
    const browseBtn = document.getElementById('browseDecks');
    const overlay = document.getElementById('deckBrowserOverlay');
    const deckList = document.getElementById('deckList');
    const deckMsg = document.getElementById('deckBrowserMsg');
    const closeBtn = document.getElementById('closeDeckBrowser');
    const refreshBtn = document.getElementById('refreshDeckList');
    async function fetchDirectory(path){
      // Try manifest first (recommended for GitHub Pages)
      try{
        const manifestRes = await fetch((path.replace(/\/$/, '') + '/manifest.json'));
        if(manifestRes && manifestRes.ok){
          const list = await manifestRes.json();
          if(Array.isArray(list)) return list;
        }
      }catch(e){ /* manifest not found ‚Äî continue to try HTML listing */ }
      try{
        const res = await fetch(path);
        if(!res.ok) throw new Error('HTTP '+res.status);
        const text = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text,'text/html');
        const anchors = Array.from(doc.querySelectorAll('a'));
        const entries = [];
        for(const a of anchors){
          let href = a.getAttribute('href')||'';
          if(!href) continue;
          // normalize
          if(href.startsWith('./')) href = href.slice(2);
          // ignore parent links
          if(href === '../' || href === '/') continue;
          // trim trailing slash for folders
          if(href.endsWith('/')) href = href;
          entries.push(href);
        }
        return Array.from(new Set(entries));
      }catch(err){
        throw err;
      }
    }

    async function openDeckBrowser(){
      if(!overlay) return;
      overlay.style.display = 'flex'; overlay.setAttribute('aria-hidden','false'); overlay.classList.add('open');
      overlay.querySelector('.modal')?.classList.add('open');
      deckList.innerHTML = '';
      deckMsg.textContent = 'Recherche de ./decks/ ...';
      try{
        const entries = await fetchDirectory('./decks/');
        if(!entries || entries.length===0){ deckMsg.textContent = 'Aucun fichier trouv√© dans ./decks/'; return }
        deckMsg.textContent = '';
        // If manifest contains paths with '/', treat as manifest-mode and build a tree
        const manifestMode = entries.some(e=> typeof e === 'string' && e.includes('/'));
        if(manifestMode){
          // keep entries for navigation
          overlay._manifestEntries = entries.slice();
          renderPath('');
        } else {
          // normal directory listing (server HTML) ‚Äî render directly
          renderList(entries, './decks/');
        }

        function renderPath(path){
          deckList.innerHTML = '';
          // path is like '' or 'Anglais/' or 'Anglais/Sub/'
          const prefix = path;
          const files = new Set();
          const folders = new Set();
          for(const p of entries){
            if(!p.startsWith(prefix)) continue;
            const tail = p.slice(prefix.length);
            const parts = tail.split('/');
            if(parts.length === 1){ files.add(parts[0]); }
            else { folders.add(parts[0] + '/'); }
          }
          // parent link
          if(prefix){
            const back = document.createElement('div'); back.className='deck-entry';
            const nm = document.createElement('div'); nm.textContent = '..';
            const act = document.createElement('div');
              const b = document.createElement('button'); b.className='secondary'; b.textContent='Retour';
            b.addEventListener('click', ()=>{ const up = prefix.replace(/[^\/]+\/$/,''); renderPath(up); });
            act.appendChild(b); back.appendChild(nm); back.appendChild(act); deckList.appendChild(back);
          }
          // folders
          Array.from(folders).sort().forEach(folder=>{
            const row = document.createElement('div'); row.className='deck-entry';
            const nm = document.createElement('div'); nm.textContent = decodeURIComponent((prefix+folder).replace(/\+/g,' ')).replace(/\/$/,'');
            const act = document.createElement('div');
            const b = document.createElement('button'); b.className='secondary'; b.textContent='Ouvrir';
            b.addEventListener('click', ()=>{ renderPath(prefix+folder); });
            act.appendChild(b); row.appendChild(nm); row.appendChild(act); deckList.appendChild(row);
          });
          // files (limit to first 10)
          Array.from(files).sort().forEach(file=>{
            const row = document.createElement('div'); row.className='deck-entry';
            const dec = decodeURIComponent((prefix+file).replace(/\+/g,' '));
            const nm = document.createElement('div'); nm.textContent = dec.replace(/\.xml$/i,'');
            const act = document.createElement('div');
              if(file.toLowerCase().endsWith('.xml')){ const dueBadge = document.createElement('span'); dueBadge.className = 'due-badge'; dueBadge.innerHTML = '<div class="due-num"></div><div class="due-label">√† faire</div>';
                const b=document.createElement('button'); b.className='secondary';
                b.textContent = (window.innerWidth <= 640) ? '‚ñ∂Ô∏è' : 'Charger';
                b.addEventListener('click', async ()=>{ await removeWelcome(); overlay.querySelector('.modal')?.classList.remove('open'); overlay.classList.remove('open'); overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); loadDeckFromURL('./decks/'+prefix+file); deckURL = './decks/'+prefix+file; });
                act.appendChild(dueBadge); act.appendChild(b);
                // asynchronously compute number of cards due now for this deck and display
                (async ()=>{
                  try{
                    const url = './decks/'+prefix+file;
                    const n = await countDueNowForDeck(url);
                    if(typeof n === 'number' && n>=0){
                      dueBadge.querySelector('.due-num').textContent = n>0? n : '';
                      // hide label when zero
                      dueBadge.querySelector('.due-label').style.display = n>0? 'block' : 'none';
                    } else { dueBadge.querySelector('.due-num').textContent = ''; dueBadge.querySelector('.due-label').style.display = 'none' }
                  }catch(e){ /* ignore */ }
                })();
              }
            row.appendChild(nm); row.appendChild(act); deckList.appendChild(row);
          });
          deckMsg.textContent = '';
        }

        async function renderList(list, base){
          deckList.innerHTML = '';
          for(const e of (list.slice ? list : list)){
            const row = document.createElement('div'); row.className='deck-entry';
            const decoded = (()=>{ try{ return decodeURIComponent(e.replace(/\+/g,' ')) }catch(x){ return e } })();
            const name = document.createElement('div'); name.textContent = decoded.replace(/\.xml$/i,'');
            const dueBadge = document.createElement('span'); dueBadge.className = 'due-badge'; dueBadge.innerHTML = '<div class="due-num"></div><div class="due-label">√† faire</div>';
            name.appendChild(dueBadge);
            const actions = document.createElement('div');
            if(e.endsWith('.xml')){ const dueBadge2 = document.createElement('span'); dueBadge2.className = 'due-badge'; dueBadge2.innerHTML = '<div class="due-num"></div><div class="due-label">√† faire</div>';
              const btn = document.createElement('button'); btn.className='secondary';
              btn.textContent = (window.innerWidth <= 640) ? 'üìÇ' : 'Charger';
              btn.addEventListener('click', async ()=>{ await removeWelcome(); overlay.querySelector('.modal')?.classList.remove('open'); overlay.classList.remove('open'); overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); loadDeckFromURL(base+e); deckURL = base+e; }); actions.appendChild(dueBadge2); actions.appendChild(btn);
                (async ()=>{ try{ const n = await countDueNowForDeck(base+e); if(typeof n === 'number' && n>=0){ dueBadge2.querySelector('.due-num').textContent = n>0? n : ''; dueBadge2.querySelector('.due-label').style.display = n>0? 'block' : 'none'; }else{ dueBadge2.querySelector('.due-num').textContent=''; dueBadge2.querySelector('.due-label').style.display='none'; } }catch(err){} })();
            }
            else { const btn = document.createElement('button'); btn.className='secondary'; btn.textContent='Ouvrir'; btn.addEventListener('click', async ()=>{ deckMsg.textContent = 'Exploration de '+base+e+' ...'; try{ const sub = await fetchDirectory(base+e); renderList(sub, base+e); }catch(err){ deckMsg.textContent = 'Impossible d\'explorer le dossier: '+err.message } }); actions.appendChild(btn); }
            row.appendChild(name); row.appendChild(actions); deckList.appendChild(row);
          }
        }
      }catch(err){ deckMsg.textContent = 'Impossible d\'acc√©der √† ./decks/ ‚Äî invoquez via un serveur HTTP (non support√© en file://)'; }
    }
    if(browseBtn) browseBtn.addEventListener('click', openDeckBrowser);
    // show tooltip first-time to indicate where to change deck
    function showDeckTooltipOnce(){
      try{
        const key = 'fabanki_seenDeckTooltip_v1';
        if(localStorage.getItem(key)) return;
        const btn = document.getElementById('browseDecks');
        if(!btn) return;
        const r = btn.getBoundingClientRect();
        const tip = document.createElement('div'); tip.className='tooltip'; tip.id='deckTooltip';
        tip.textContent = 'Cliquer ici pour choisir un deck';
        document.body.appendChild(tip);
        // position above the button
        tip.style.left = (r.left + window.scrollX) + 'px';
        tip.style.top = (r.bottom + window.scrollY + 8) + 'px';
        setTimeout(()=>{ try{ tip.style.opacity='0'; tip.remove(); localStorage.setItem(key,'1') }catch(e){} }, 3800);
      }catch(e){}
    }
    showDeckTooltipOnce();
    if(closeBtn) closeBtn.addEventListener('click', ()=>{ if(overlay){ overlay.querySelector('.modal')?.classList.remove('open'); overlay.classList.remove('open'); overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); } });
    if(overlay){ overlay.addEventListener('click', (ev)=>{ if(ev.target === overlay){ overlay.querySelector('.modal')?.classList.remove('open'); overlay.classList.remove('open'); overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); } }); }
    if(refreshBtn) refreshBtn.addEventListener('click', ()=>{ openDeckBrowser(); });
    
    // Helper: parse card ids from an XML document (lightweight, used by deck browser counts)
    function parseCardIdsFromXML(xml){
      const cardNodes = Array.from(xml.getElementsByTagName('card'));
      const candidates = cardNodes.length ? cardNodes : Array.from(xml.querySelectorAll('card, note, item, entry, record'));
      const ids = [];
      let idx = 0;
      for(const node of candidates){
        try{ const id = node.getAttribute('id') || node.getAttribute('guid') || ('card-'+(idx++)); ids.push(id); }catch(e){ continue }
      }
      return ids;
    }

    // Count number of cards due now for a deck URL (considers localStorage state for that deck)
    async function countDueNowForDeck(url){
      try{
        const res = await fetch(url);
        if(!res.ok) return 0;
        const text = await res.text();
        const parser = new DOMParser();
        let xml = parser.parseFromString(text,'application/xml');
        if(xml.querySelector && xml.querySelector('parsererror')) xml = parser.parseFromString(text,'text/html');
        const ids = parseCardIdsFromXML(xml);
        const keyPrefix = 'fabanki:' + fallbackSha1(url).slice(0,10) + ':';
        const now = new Date();
        let cnt = 0;
        for(const id of ids){
          try{
            const key = keyPrefix + 'card:' + id;
            const st = JSON.parse(localStorage.getItem(key) || '{}');
            const isNew = (!st || (!st.last && (st.reps===0 || st.reps===undefined)));
            if(isNew) continue;
            const due = st && st.due ? new Date(st.due) : now;
            if(due <= now) cnt++;
          }catch(e){ continue }
        }
        return cnt;
      }catch(e){ return 0 }
    }
    // toggle histogram button (mobile: overlay, desktop: scroll)
    const toggleStatsBtn = document.getElementById('toggleStats');
    if(toggleStatsBtn){
      toggleStatsBtn.addEventListener('click', ()=>{
        const stats = document.getElementById('stats');
        if(!stats) return;
        if(window.innerWidth <= 640){ stats.classList.toggle('visible'); }
        else { stats.scrollIntoView({behavior:'smooth'}); }
      });
    }

    // Mobile-only: replace top-bar button labels with emojis.
    function updateTopBarLabels(){
      try{
        const isMobile = window.innerWidth <= 640;
        const buttons = document.querySelectorAll('header .controls button[data-label-text]');
        buttons.forEach(btn=>{
          const text = btn.getAttribute('data-label-text') || btn.textContent;
          const emoji = btn.getAttribute('data-label-emoji') || text;
          btn.textContent = isMobile ? emoji : text;
        });
        // no inline profile badge; profile info shown in popup on click
      }catch(e){}
    }
    updateTopBarLabels();
    window.addEventListener('resize', updateTopBarLabels);

    // Hide status and hint when mobile stats overlay is visible
    (function(){
      try{
        const statsEl = document.getElementById('stats');
        if(!statsEl) return;
        const handle = ()=>{
          const isVis = statsEl.classList.contains('visible');
          const isMobile = window.innerWidth <= 640;
          const s = document.getElementById('status');
          const hint = document.getElementById('histHint');
          if(isMobile && isVis){ if(s) s.style.display='none'; if(hint) hint.style.display='none'; }
          else { if(s) s.style.display=''; if(hint) hint.style.display=''; try{ updateStatus(s?.textContent || '') }catch(e){} }
        };
        // observe class changes
        const mo = new MutationObserver(handle);
        mo.observe(statsEl, { attributes: true, attributeFilter: ['class'] });
        // also run once to sync initial state
        window.addEventListener('load', handle);
        window.addEventListener('resize', handle);
      }catch(e){}
    })();
    // Hide card status when any modal or stats overlay is visible
    (function(){
      function anyModalOpen(){
        try{
          const overlays = Array.from(document.querySelectorAll('.modal-overlay'));
          for(const o of overlays){
            const aria = o.getAttribute('aria-hidden');
            const disp = (o.style && o.style.display) || getComputedStyle(o).display;
            if(aria === 'false' || disp !== 'none') return true;
          }
          const stats = document.getElementById('stats'); if(stats && stats.classList.contains('visible')) return true;
        }catch(e){}
        return false;
      }
      function syncCardStatus(){
        try{
          const st = document.getElementById('cardStatus'); if(!st) return;
          if(anyModalOpen()) st.style.display = 'none'; else st.style.display = '';
        }catch(e){}
      }
      try{
        const mo = new MutationObserver(syncCardStatus);
        mo.observe(document.body, {subtree:true, childList:true, attributes:true, attributeFilter:['style','aria-hidden','class']});
      }catch(e){}
      setTimeout(syncCardStatus, 120);
      window.addEventListener('resize', syncCardStatus);
    })();

    // Also hide status/hint when the deck browser overlay is visible on mobile
    (function(){
      try{
        const deckOverlay = document.getElementById('deckBrowserOverlay');
        if(!deckOverlay) return;
        const handleDeck = ()=>{
          const isOpen = deckOverlay.style.display === 'flex' || deckOverlay.getAttribute('aria-hidden') === 'false';
          const isMobile = window.innerWidth <= 640;
          const s = document.getElementById('status');
          const hint = document.getElementById('histHint');
          if(isMobile && isOpen){ if(s) s.style.display='none'; if(hint) hint.style.display='none'; }
          else { if(s) s.style.display=''; if(hint) hint.style.display=''; try{ updateStatus(s?.textContent || '') }catch(e){} }
        };
        const mo2 = new MutationObserver(handleDeck);
        mo2.observe(deckOverlay, { attributes:true, attributeFilter:['style','aria-hidden'] });
        window.addEventListener('resize', handleDeck);
        window.addEventListener('load', handleDeck);
      }catch(e){}
    })();
    // close button for mobile histogram overlay
    const closeStatsBtn = document.getElementById('closeStatsMobile');
    if(closeStatsBtn){
      closeStatsBtn.addEventListener('click', ()=>{
        const stats = document.getElementById('stats'); if(!stats) return; stats.classList.remove('visible');
      });
    }

    // check URL param
    const pdeck = param('deck');
    // Profile & XP helpers
    function getProfileStats(){
      let total = 0, today = 0;
      const now = new Date();
      for(const k of Object.keys(localStorage)){
        // support keys like 'fabanki:<deckKey>:card:<id>' and older 'fabanki:card:<id>'
        if(!k.includes(':card:')) continue;
        try{
          const st = JSON.parse(localStorage.getItem(k) || '{}');
          // Count as reviewed if it has reps>0 OR it was seen (has last) ‚Äî include Pass actions
          if(st && ((st.reps && st.reps>0) || st.last)) total++;
          if(st && st.last){ const d = new Date(st.last); if(d.toDateString() === now.toDateString()) today++; }
        }catch(e){}
      }
      const xp = Number(localStorage.getItem('fabanki:xp_total') || 0);
      return {totalReviewed: total, todayReviewed: today, xpTotal: xp};
    }

    function showProfilePopup(){
      try{
        // prevent duplicates
        if(document.getElementById('profileOverlay')) return;
        const stats = getProfileStats();
        const ov = document.createElement('div'); ov.id='profileOverlay'; ov.className='modal-overlay'; ov.style.display='flex'; ov.style.alignItems='center'; ov.style.justifyContent='center'; ov.style.zIndex='1200';
        const m = document.createElement('div'); m.className='modal'; m.style.maxWidth='420px'; m.style.width='90%';
        const h = document.createElement('h3'); h.textContent='Profil'; m.appendChild(h);
        // Pseudo display (from localStorage)
        const userPseudo = localStorage.getItem('pseudo') || '';
        const p0 = document.createElement('div'); p0.id='profilePseudo'; p0.className='muted small'; p0.style.marginBottom='6px'; p0.textContent = `Pseudo: ${userPseudo}`;
        // modifier button
        const editBtn = document.createElement('button'); editBtn.className='secondary'; editBtn.style.marginLeft='8px'; editBtn.textContent = 'Modifier';
        editBtn.addEventListener('click', ()=>{
          try{
            const cur = localStorage.getItem('pseudo') || '';
            const input = document.createElement('input'); input.type='text'; input.value = cur; input.style.width='60%'; input.style.marginLeft='8px';
            const save = document.createElement('button'); save.className='secondary'; save.textContent='Enregistrer'; save.style.marginLeft='6px';
            const cancel = document.createElement('button'); cancel.className='secondary'; cancel.textContent='Annuler'; cancel.style.marginLeft='6px';
            p0.textContent = 'Pseudo : '; p0.appendChild(input); p0.appendChild(save); p0.appendChild(cancel);
            save.addEventListener('click', ()=>{ const v = (input.value||'').trim(); if(!v) return input.focus(); localStorage.setItem('pseudo', v); if(typeof updateProfilePopupIfOpen === 'function') updateProfilePopupIfOpen(); try{ if(typeof syncClassement === 'function') syncClassement(); }catch(e){} });
            cancel.addEventListener('click', ()=>{ p0.textContent = `Pseudo: ${localStorage.getItem('pseudo') || ''}` });
          }catch(e){ console.warn('edit pseudo', e) }
        });
        const pWrap = document.createElement('div'); pWrap.style.display='flex'; pWrap.style.alignItems='center'; pWrap.appendChild(p0); pWrap.appendChild(editBtn); m.appendChild(pWrap);
        const p1 = document.createElement('div'); p1.className='muted small profile-total'; p1.textContent = `Cartes lues: ${stats.totalReviewed}`; m.appendChild(p1);
        const p2 = document.createElement('div'); p2.className='muted small profile-today'; p2.textContent = `Cartes lues aujourd'hui: ${stats.todayReviewed}`; m.appendChild(p2);
        
        const p4 = document.createElement('div'); p4.className='muted small profile-streak'; p4.style.marginTop='6px'; p4.textContent = `Jours cons√©cutifs: ${Number(localStorage.getItem('fabanki:streak_current')||0)}`; m.appendChild(p4);

        // Classement button
        const rankBtnWrap = document.createElement('div'); rankBtnWrap.style.marginTop = '10px'; rankBtnWrap.style.display = 'flex'; rankBtnWrap.style.gap = '8px';
        const rankBtn = document.createElement('button'); rankBtn.className = 'secondary'; rankBtn.textContent = 'Classement';
        rankBtn.addEventListener('click', ()=>{ try{ showLeaderboardPopup(); }catch(e){ console.warn(e) } });
        rankBtnWrap.appendChild(rankBtn);
        // Titres button
        const titlesBtn = document.createElement('button'); titlesBtn.className='secondary'; titlesBtn.textContent = 'Titres';
        titlesBtn.addEventListener('click', ()=>{ try{ showTitlesPopup(); }catch(e){ console.warn(e) } });
        rankBtnWrap.appendChild(titlesBtn);
        m.appendChild(rankBtnWrap);
        const p3 = document.createElement('div'); p3.className='muted small profile-xp'; p3.style.marginTop='8px'; p3.innerHTML = `<strong>XP:</strong> ${stats.xpTotal}`; m.appendChild(p3);
        // Level box: ring + info
        try{
          const lvl = computeLevelAndProgress(stats.xpTotal || 0);
          const levelBox = document.createElement('div'); levelBox.className = 'level-box';
          const ring = document.createElement('div'); ring.className = 'level-ring';
          const circ = 2 * Math.PI * 42;
          const pct = Math.max(0, Math.min(100, Math.round(lvl.pct || 0)));
          const offset = Math.round(circ * (1 - pct/100));
          const color = getLevelColor(lvl.level);
          ring.innerHTML = `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="42" stroke="#eee" stroke-width="8" fill="none"></circle><circle class="ring-fill" cx="50" cy="50" r="42" stroke="${color}" stroke-width="8" fill="none" stroke-linecap="round" stroke-dasharray="${circ}" stroke-dashoffset="${offset}"></circle></svg><div class="level-num">${lvl.level}</div>`;
          const info = document.createElement('div'); info.className='level-info';
          const next = document.createElement('div'); next.className='next muted small'; next.textContent = `Prochain niveau dans ${lvl.toNext} XP`;
          const rem = document.createElement('div'); rem.className='progress-remaining'; rem.textContent = `${lvl.progress}/${lvl.need} (${pct}%)`;
          info.appendChild(next); info.appendChild(rem);
          levelBox.appendChild(ring); levelBox.appendChild(info);
          m.appendChild(levelBox);
        }catch(e){ /* ignore level rendering errors */ }

        const close = document.createElement('div'); close.style.display='flex'; close.style.justifyContent='flex-end'; close.style.marginTop='12px';
        const cb = document.createElement('button'); cb.className='secondary'; cb.textContent='Fermer'; cb.addEventListener('click', ()=>{ ov.remove(); }); close.appendChild(cb);
        m.appendChild(close);
        ov.appendChild(m); document.body.appendChild(ov);
        // mark overlay open so CSS fade can run, then animate modal open
        try{ ov.classList.add('open'); ov.setAttribute('aria-hidden','false'); m.classList.add('open'); }catch(e){}
        ov.addEventListener('click', (ev)=>{ if(ev.target === ov) ov.remove(); });
      }catch(e){ console.warn('profile popup error', e); }
    }

    function updateProfilePopupIfOpen(){
      try{
        const ov = document.getElementById('profileOverlay');
        if(!ov) return;
        const stats = getProfileStats();
        const pseudoNode = ov.querySelector('#profilePseudo'); if(pseudoNode) pseudoNode.textContent = `Pseudo: ${localStorage.getItem('pseudo') || ''}`;
        const totalNode = ov.querySelector('.profile-total'); if(totalNode) totalNode.textContent = `Cartes lues: ${stats.totalReviewed}`;
        const todayNode = ov.querySelector('.profile-today'); if(todayNode) todayNode.textContent = `Cartes lues aujourd'hui: ${stats.todayReviewed}`;
        const xpNode = ov.querySelector('.profile-xp'); if(xpNode) xpNode.innerHTML = `<strong>XP:</strong> ${stats.xpTotal}`;
        // update level ring if present
        try{
          const lvl = computeLevelAndProgress(stats.xpTotal || 0);
          const ringFill = ov.querySelector('.level-ring .ring-fill');
          const levelNum = ov.querySelector('.level-ring .level-num');
          const nextTxt = ov.querySelector('.level-info .next');
          const remTxt = ov.querySelector('.level-info .progress-remaining');
          if(ringFill){ const circ = 2 * Math.PI * 42; const pct = Math.max(0, Math.min(100, Math.round(lvl.pct || 0))); ringFill.style.stroke = getLevelColor(lvl.level); ringFill.setAttribute('stroke-dasharray', String(circ)); ringFill.setAttribute('stroke-dashoffset', String(Math.round(circ * (1 - pct/100)))); }
          if(levelNum) levelNum.textContent = String(lvl.level);
          if(nextTxt) nextTxt.textContent = `Prochain niveau dans ${lvl.toNext} XP`;
          if(remTxt) remTxt.textContent = `${lvl.progress}/${lvl.need} (${Math.round(lvl.pct||0)}%)`;
        }catch(e){}
        // refresh pseudo display (target the specific element, not the first div)
        try{ const p0 = ov.querySelector('#profilePseudo'); if(p0) p0.textContent = `Pseudo: ${localStorage.getItem('pseudo') || ''}` }catch(e){}
        try{ const s = ov.querySelector('.profile-streak'); if(s) s.textContent = `Jours cons√©cutifs: ${Number(localStorage.getItem('fabanki:streak_current')||0)}` }catch(e){}
      }catch(e){}
    }

    // expose helpers globally so other handlers (outside load) can use them
    try{ window.applyXp = applyXp; window.computeXpForQuality = computeXpForQuality; window.getDeckSection = getDeckSection; window.showXpToast = showXpToast; window.getXpTotal = getXpTotal; window.updateProfilePopupIfOpen = updateProfilePopupIfOpen; window.computePenaltyForSection = computePenaltyForSection; window.computeLevelAndProgress = computeLevelAndProgress; window.getLevelColor = getLevelColor; }catch(e){}

    // expose leaderboard helpers
    try{ window.ensurePseudo = ensurePseudo; window.syncClassement = syncClassement; window.showLeaderboardPopup = showLeaderboardPopup; }catch(e){}

    const profileBtn = document.getElementById('profileBtn');
    if(profileBtn) profileBtn.addEventListener('click', ()=>{ showProfilePopup(); updateProfilePopupIfOpen(); });
    // refresh periodically
    setInterval(()=>{ try{ updateProfilePopupIfOpen(); }catch(e){} }, 30*1000);

    // XP helpers
    function getXpTotal(){ return Number(localStorage.getItem('fabanki:xp_total') || 0); }
    function applyXp(delta){
      try{
        let total = getXpTotal();
        const prevLevel = computeLevelAndProgress(total).level;
        if(delta < 0){ if(total <= 0) return 0; const remove = Math.min(total, Math.abs(delta)); total -= remove; localStorage.setItem('fabanki:xp_total', total); return -remove; }
        total += delta; localStorage.setItem('fabanki:xp_total', total);
        try{ resetWeeklyIfNeeded(); const curWeekXp = Number(localStorage.getItem('fabanki:xp_semaine') || 0) + Math.max(0, delta); localStorage.setItem('fabanki:xp_semaine', String(curWeekXp)); }catch(e){}
        const newLevel = computeLevelAndProgress(total).level;
        // If level increased, show notification
        if(newLevel > prevLevel){ try{ showLevelUpNotification(newLevel, prevLevel); }catch(e){} }
        return delta;
      }catch(e){ return 0 }
    }

    function getDeckSection(){
      try{
        const u = (deckURL || '').toLowerCase(); const t = (deck.title || '').toLowerCase();
        const s = u || t;
        if(!s) return '';
        if(s.includes('math')) return 'maths';
        if(s.includes('phys')) return 'physique';
        if(s.includes('sciences') || s.includes('industri')) return 'si';
        if(s.includes('informat')) return 'info';
        if(s.includes('anglais')) return 'anglais';
        if(s.includes('fran')) return 'francais';
        return '';
      }catch(e){ return '' }
    }

    // --- Pseudo & Leaderboard (cloud sync) ---
    function generateUserId(){
      try{ if(window.crypto && crypto.getRandomValues){ const a = new Uint8Array(16); crypto.getRandomValues(a); return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join(''); } }catch(e){}
      return 'u-' + Date.now() + '-' + Math.floor(Math.random()*100000);
    }

    function ensurePseudo(){
      try{
        let p = localStorage.getItem('pseudo');
        let uid = localStorage.getItem('userId');
        if(!uid){ uid = generateUserId(); localStorage.setItem('userId', uid); }
        if(!p){ showPseudoModal(); return false; }
        return true;
      }catch(e){ return false }
    }

    function showPseudoModal(){
      try{
        if(document.getElementById('pseudoOverlay')) return;
        const ov = document.createElement('div'); ov.id='pseudoOverlay'; ov.className='modal-overlay'; ov.style.display='flex'; ov.style.alignItems='center'; ov.style.justifyContent='center'; ov.style.zIndex='2500';
        const m = document.createElement('div'); m.className='modal'; m.style.maxWidth='520px'; m.style.width='94%';
        const h = document.createElement('h3'); h.textContent = "Entre ton Pseudo"; m.appendChild(h);
        const inp = document.createElement('input'); inp.type='text'; inp.placeholder='Ton Pseudo'; inp.style.width='100%'; inp.style.padding='8px'; inp.style.fontSize='1rem'; inp.style.marginTop='8px';
        m.appendChild(inp);
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='flex-end'; row.style.gap='8px'; row.style.marginTop='12px';
        const btn = document.createElement('button'); btn.className='secondary'; btn.textContent='Valider';
        btn.addEventListener('click', ()=>{
          const v = (inp.value || '').trim(); if(!v) return inp.focus();
          localStorage.setItem('pseudo', v);
          if(!localStorage.getItem('userId')) localStorage.setItem('userId', generateUserId());
          try{ if(typeof updateProfilePopupIfOpen === 'function') updateProfilePopupIfOpen(); }catch(e){}
          try{ if(typeof syncClassement === 'function') syncClassement(); }catch(e){}
          ov.remove();
        });
        row.appendChild(btn); m.appendChild(row); ov.appendChild(m); document.body.appendChild(ov);
        try{ m.classList.add('open'); ov.classList.add('open'); }catch(e){}
        ov.addEventListener('click', (ev)=>{ if(ev.target === ov) ov.remove(); });
      }catch(e){ console.warn('pseudo modal error', e) }
    }

    // Weekly helpers
    function getWeekId(d){ // ISO-like YYYY-WW
      try{
        const dt = d ? new Date(d) : new Date();
        const y = dt.getFullYear();
        // get ISO week number approximation
        const onejan = new Date(y,0,1);
        const days = Math.floor((dt - onejan) / 86400000);
        const week = String(Math.floor((days + onejan.getDay()+1)/7)+1).padStart(2,'0');
        return `${y}-${week}`;
      }catch(e){ return (new Date()).toISOString().slice(0,8) }
    }

    function resetWeeklyIfNeeded(){
      try{
        const currentWeek = getWeekId();
        const stored = localStorage.getItem('fabanki:week_id');
        if(stored !== currentWeek){
          localStorage.setItem('fabanki:week_id', currentWeek);
          localStorage.setItem('fabanki:xp_semaine', '0');
          localStorage.setItem('fabanki:score_mpsi_semaine', '0');
        }
      }catch(e){}
    }

    function getDayId(d){ try{ return (d? new Date(d): new Date()).toISOString().slice(0,10); }catch(e){ return (new Date()).toISOString().slice(0,10) } }

    function resetDailyIfNeeded(){
      try{
        const currentDay = getDayId();
        const stored = localStorage.getItem('fabanki:day_id');
        if(stored !== currentDay){
          localStorage.setItem('fabanki:day_id', currentDay);
          localStorage.setItem('fabanki:score_mpsi_today', '0');
        }
      }catch(e){}
    }

    function getMonthId(d){ try{ const dt = d? new Date(d): new Date(); return dt.getFullYear() + '-' + String(dt.getMonth()+1).padStart(2,'0'); }catch(e){ return (new Date()).toISOString().slice(0,7) } }

    function resetMonthlyIfNeeded(){
      try{
        const current = getMonthId();
        const stored = localStorage.getItem('fabanki:month_id');
        if(stored !== current){
          localStorage.setItem('fabanki:month_id', current);
          localStorage.setItem('fabanki:score_mpsi_mois','0');
        }
      }catch(e){}
    }

    function incLocal(key, n){ try{ const v = Number(localStorage.getItem(key) || 0) + (n||1); localStorage.setItem(key, String(v)); return v; }catch(e){ return 0 } }

    function getLocalNum(key){ return Number(localStorage.getItem(key) || 0) }

    function countMasteredCards(){
      try{
        let cnt = 0;
        for(const k of Object.keys(localStorage)){
          if(!k.includes(':card:')) continue;
          try{ const st = JSON.parse(localStorage.getItem(k) || '{}'); if(st && st.reps && st.reps >= 3) cnt++; }catch(e){}
        }
        return cnt;
      }catch(e){ return 0 }
    }

    function computeBadges(stats){
      // Backwards-compatible wrapper: compute titles and return top textual badges
      try{
        const out = [];
        const computed = computeTitles(stats || {});
        const titres = computed.titres || [];
        for(const t of titres.slice(0,3)){
          const roman = tierToRoman(t.tier || 0);
          out.push(`${t.nom} ${roman}`);
        }
        // if none, fall back to some simple legacy badges
        if(out.length === 0){
          const legacy = [];
          const streak = Number(localStorage.getItem('fabanki:streak_max') || 0);
          const good = Number(localStorage.getItem('fabanki:good_total') || 0);
          const reviewed = stats.totalReviewed || 0;
          const pass = Number(localStorage.getItem('fabanki:pass_total') || 0);
          if(streak >= 5) legacy.push('R√©gularit√©');
          if(good >= 200) legacy.push('Pr√©cision');
          if(reviewed >= 1000) legacy.push('Endurance');
          if((reviewed - pass) >= 50) legacy.push('Z√©ro gaspillage');
          return legacy;
        }
        return out;
      }catch(e){ return [] }
    }

    function tierToRoman(t){ const map=['','I','II','III','IV','V']; return map[Number(t)||0]||String(t); }

    function computeTitles(stats){
      // stats should include totalReviewed, todayReviewed, xpTotal
      try{
        const titres = [];
        const objectifs = [];
        const bonnes = Number(localStorage.getItem('fabanki:good_total') || 0);
        const reviewed = Number(stats.totalReviewed || 0);
        const passes = Number(localStorage.getItem('fabanki:pass_total') || 0);
        const mastered = Number(localStorage.getItem('fabanki:mastered_total') || countMasteredCards());
        const streakMax = Number(localStorage.getItem('fabanki:streak_max') || 0);
        const consecCardMax = Number(localStorage.getItem('fabanki:consec_correct_max') || 0);
        const consecNoPassMax = Number(localStorage.getItem('fabanki:consec_no_pass_max') || 0);
        const streakCurrent = Number(localStorage.getItem('fabanki:streak_current') || 0);
        const longCount = Number(localStorage.getItem('fabanki:long_answer_total') || 0);

        // Helper to compute highest tier from thresholds array
        const highestTier = (value, thresholds)=>{
          let tier = 0; for(let i=0;i<thresholds.length;i++){ if(value >= thresholds[i]) tier = i+1; }
          return tier;
        };

        // Define title thresholds
        const defs = [
          {nom:'Gauss', th:[100,300,600,1000,2000], val: bonnes},
          {nom:'Fourier', th:[200,600,1200,2500,5000], val: reviewed},
          {nom:'Euler', th:[200,500,1000,2000,4000], val: (reviewed>0? Math.round((bonnes/reviewed)*100):0), isPercent:true, percentDefs:[0.75,0.80,0.85,0.90,0.92]},
          {nom:'Newton', th:[20,50,100,200,365], val: consecCardMax},
          {nom:'Maxwell', th:[3,7,21,60,120], val: streakCurrent},
          {nom:'Noether', th:[50,150,400,1000,3000], val: consecNoPassMax},
          {nom:'Hadamard', th:[50,150,400,1000,3000], val: longCount}
        ];
        for(const d of defs){
          let tier = 0;
          if(d.isPercent){
            for(let i=0;i<d.percentDefs.length;i++){ if(reviewed >= d.th[i] && (bonnes/reviewed) >= d.percentDefs[i]) tier = i+1; }
          } else {
            tier = highestTier(d.val, d.th);
          }
          titres.push({nom: d.nom, tier});
        }

        // Special one-shot objectifs
        try{
          // Lagrange: 95% de bonnes r√©ponses sur 500 cartes
          if(reviewed >= 500 && reviewed>0 && (bonnes / reviewed) >= 0.95){ objectifs.push('Lagrange'); localStorage.setItem('fabanki:objective_Lagrange','1'); }
          // Cauchy: aucune 'Passer' sur 300 cartes
          if(reviewed >= 300 && passes === 0){ objectifs.push('Cauchy'); localStorage.setItem('fabanki:objective_Cauchy','1'); }
          // Laplace, Feynman, Ramanujan: detect via explicit flags if present (allow server/backfill)
          if(localStorage.getItem('fabanki:objective_Laplace') === '1') objectifs.push('Laplace');
          if(localStorage.getItem('fabanki:objective_Feynman') === '1') objectifs.push('Feynman');
          if(localStorage.getItem('fabanki:objective_Ramanujan') === '1') objectifs.push('Ramanujan');
        }catch(e){}

        return { titres, objectifs };
      }catch(e){ return {titres:[], objectifs:[]} }
    }

    // Synchronize local profile/Xp to Firestore under collection 'Classement'
    async function syncClassement(){
      try{
        const db = window.__fabanki_firestore;
        if(!db) return false;
        const userId = localStorage.getItem('userId') || generateUserId();
        const pseudo = localStorage.getItem('pseudo') || 'Anonyme';
        const xp = Number(localStorage.getItem('fabanki:xp_total') || 0);
        const lvl = (typeof computeLevelAndProgress === 'function') ? computeLevelAndProgress(xp).level : 1;
        // ensure weekly counters are current
        resetWeeklyIfNeeded();
        // update daily streak information
        try{
          const today = (new Date()).toDateString();
          const last = localStorage.getItem('fabanki:last_active_date');
          if(last === today){ /* already recorded today */ }
          else {
            const yesterday = new Date(); yesterday.setDate(yesterday.getDate()-1);
            if(last === yesterday.toDateString()){
              const cur = Number(localStorage.getItem('fabanki:streak_current')||0) + 1; localStorage.setItem('fabanki:streak_current', String(cur));
              const maxi = Math.max(Number(localStorage.getItem('fabanki:streak_max')||0), cur); localStorage.setItem('fabanki:streak_max', String(maxi));
            } else {
              localStorage.setItem('fabanki:streak_current', '1');
              const maxi = Math.max(Number(localStorage.getItem('fabanki:streak_max')||0), 1); localStorage.setItem('fabanki:streak_max', String(maxi));
            }
            localStorage.setItem('fabanki:last_active_date', today);
          }
        }catch(e){}
        const stats = getProfileStats();
        const cartes = stats.totalReviewed || 0;
        const bonnes = Number(localStorage.getItem('fabanki:good_total') || 0);
        const rates = Number(localStorage.getItem('fabanki:fail_total') || 0);
        const passes = Number(localStorage.getItem('fabanki:pass_total') || 0);
        const mastered = Number(localStorage.getItem('fabanki:mastered_total') || countMasteredCards());
        const streakMax = Number(localStorage.getItem('fabanki:streak_max') || 0);
        const xpS = Number(localStorage.getItem('fabanki:xp_semaine') || 0);
        const scoreWeekLocal = Number(localStorage.getItem('fabanki:score_mpsi_semaine') || 0);
        const scoreMonthLocal = Number(localStorage.getItem('fabanki:score_mpsi_mois') || 0);
        // compute Score MPSI
        const scoreMPSI = (mastered * 6) + (bonnes * 2) + (streakMax * 10) - (rates * 4) - (passes * 6);
        // determine friendly Niveau label (happy-medium tone)
        let niveauPrep = 'D√©butant';
        if(scoreMPSI >= 7000) niveauPrep = 'Expert';
        else if(scoreMPSI >= 4000) niveauPrep = 'Avanc√©';
        else if(scoreMPSI >= 2000) niveauPrep = '√âquilibr√©';
        else if(scoreMPSI >= 800) niveauPrep = 'Progression';
        else niveauPrep = 'D√©butant';

        const computedTitles = (typeof computeTitles === 'function') ? computeTitles(stats) : {titres:[], objectifs:[]};
        const titres = computedTitles.titres || [];
        const objectifs = computedTitles.objectifs || [];
        // prepare textual badges for backward compatibility (top 3)
        const badges = (titres.length>0) ? titres.slice(0,3).map(t=> (t.nom || '') + ' ' + tierToRoman(t.tier || 0)) : computeBadges(stats);

        // prepare daily stats and objectives persistence
        try{
          // ensure daily counters are current
          resetDailyIfNeeded();
          // cards since last streak reset: if streak was reset now (not consecutive), reset counter
          try{
            const today = (new Date()).toDateString();
            const last = localStorage.getItem('fabanki:last_active_date');
            const yesterday = new Date(); yesterday.setDate(yesterday.getDate()-1);
            if(!(last === yesterday.toDateString())){
              // streak reset occurred
              localStorage.setItem('fabanki:cards_since_streak_reset','0');
            }
          }catch(e){}
          // handle Ramanujan: consecutive days with score_mpsi_today > 200
          try{
            const todayScore = Number(localStorage.getItem('fabanki:score_mpsi_today') || 0);
            const lastOver = localStorage.getItem('fabanki:last_score_over200_date');
            const daysStreak = Number(localStorage.getItem('fabanki:days_score_over200_streak') || 0);
            const todayDate = getDayId();
            const yesterdayDate = getDayId(new Date(Date.now() - 86400000));
            let newDays = daysStreak;
            if(todayScore > 200){
              if(lastOver === yesterdayDate) newDays = daysStreak + 1; else newDays = 1;
              localStorage.setItem('fabanki:last_score_over200_date', todayDate);
            } else {
              newDays = 0; localStorage.removeItem('fabanki:last_score_over200_date');
            }
            localStorage.setItem('fabanki:days_score_over200_streak', String(newDays));
            // persist objective if reached
            if(newDays >= 10) localStorage.setItem('fabanki:objective_Ramanujan','1');
              // Laplace: cards reviewed since last streak reset
              try{ const cardsSince = Number(localStorage.getItem('fabanki:cards_since_streak_reset')||0); if(cardsSince >= 1000) localStorage.setItem('fabanki:objective_Laplace','1'); }catch(e){}
          }catch(e){}
        }catch(e){}

        // prepare doc
        const nowIso = (new Date()).toISOString();
        const weekId = getWeekId();
        const monthId = getMonthId();
        const doc = {
          Pseudo: pseudo,
          XP: xp,
          Niveau: lvl,
          ['Cartes r√©vis√©es']: cartes,
          ['Derni√®re mise √† jour']: nowIso,
          ['Derni√®re synchronisation']: nowIso,
          Score_MPSI: scoreMPSI,
          ['Bonnes r√©ponses']: bonnes,
          ['Rat√©s']: rates,
          ['Passer']: passes,
          ['Streak_max']: streakMax,
          ['Cartes ma√Ætris√©es']: mastered,
          Badges: badges,
          Titres: titres,
          Objectifs: objectifs,
          Titres: titres,
          Objectifs: objectifs,
          XP_semaine: xpS,
          Score_MPSI_semaine: scoreWeekLocal,
          Semaine_ID: weekId,
          Score_MPSI_mois: scoreMonthLocal,
          Mois_ID: monthId,
          ['Niveau Pr√©pa']: niveauPrep
        };

        // Anti-cheat: fetch previous doc and compare deltas
        try{
          const ref = db.collection('Classement').doc(userId);
          const prev = await ref.get();
          if(prev && prev.exists){
            const pd = prev.data() || {};
            const prevScore = Number(pd.Score_MPSI || 0);
            const prevCards = Number(pd['Cartes r√©vis√©es'] || 0);
            const prevSync = pd['Derni√®re synchronisation'] || pd['Derni√®re mise √† jour'] || null;
            if(prevSync){
              const prevDate = new Date(prevSync);
              const mins = (Date.now() - prevDate.getTime()) / 60000;
              if((scoreMPSI - prevScore) > 400 && mins < 10){ console.warn('Synchronisation bloqu√©e (progression irr√©aliste)'); return false }
              if((cartes - prevCards) > 80 && mins < 10){ console.warn('Synchronisation bloqu√©e (progression irr√©aliste)'); return false }
            }
          }
        }catch(e){ console.warn('syncClassement anti-cheat check failed', e) }

        try{
          // detect title upgrades compared to local cache and show toasts
          try{
            const prevCacheRaw = localStorage.getItem('fabanki:titles_cache') || '{}';
            const prevCache = JSON.parse(prevCacheRaw || '{}');
            const newCache = prevCache || {};
            (titres || []).forEach(tt => {
              try{
                const name = tt.nom || '';
                const newTier = Number(tt.tier || 0);
                const oldTier = Number(prevCache[name] || 0);
                if(newTier > oldTier){ try{ showTitleUpNotification(name, newTier, oldTier); }catch(e){} }
                newCache[name] = newTier;
              }catch(e){}
            });
            try{ localStorage.setItem('fabanki:titles_cache', JSON.stringify(newCache)); }catch(e){}
          }catch(e){ /* ignore cache errors */ }
        }catch(e){}
        await db.collection('Classement').doc(userId).set(doc, {merge:true});
        return true;
      }catch(e){ console.warn('syncClassement', e); return false }
    }

    // Leaderboard popup (real-time listener)
    function showLeaderboardPopup(){
      try{
        if(document.getElementById('leaderboardOverlay')) return;
        const db = window.__fabanki_firestore;
        const ov = document.createElement('div'); ov.id='leaderboardOverlay'; ov.className='modal-overlay'; ov.style.display='flex'; ov.style.alignItems='center'; ov.style.justifyContent='center'; ov.style.zIndex='2200';
        const m = document.createElement('div'); m.className='modal'; m.style.maxWidth='860px'; m.style.width='94%'; m.style.maxHeight='80vh'; m.style.overflow='auto';
        const h = document.createElement('h3'); h.textContent = 'Classement'; m.appendChild(h);
        // tabs
        const tabs = document.createElement('div'); tabs.style.display='flex'; tabs.style.gap='8px'; tabs.style.marginBottom='8px';
        const tabGlobal = document.createElement('button'); tabGlobal.className='secondary'; tabGlobal.textContent='Classement global';
        const tabWeek = document.createElement('button'); tabWeek.className='secondary'; tabWeek.textContent='Classement du mois';
        tabs.appendChild(tabGlobal); tabs.appendChild(tabWeek); m.appendChild(tabs);
        const table = document.createElement('table'); table.className = 'leaderboard-table'; table.style.width='100%'; table.style.borderCollapse='collapse';
        const thead = document.createElement('thead'); thead.innerHTML = '<tr><th>Rang</th><th>Pseudo</th><th>Niveau</th><th>Titres</th><th>Score MPSI</th><th>Cartes</th></tr>';
        table.appendChild(thead);
        const tbody = document.createElement('tbody'); table.appendChild(tbody);
        m.appendChild(table);
        const closeDiv = document.createElement('div'); closeDiv.style.display='flex'; closeDiv.style.justifyContent='flex-end'; closeDiv.style.marginTop='8px';
        const cb = document.createElement('button'); cb.className='secondary'; cb.textContent='Fermer'; cb.addEventListener('click', ()=>{ try{ if(typeof unsubGlobal === 'function') unsubGlobal(); if(typeof unsubWeek === 'function') unsubWeek(); }catch(e){} ov.remove(); }); closeDiv.appendChild(cb); m.appendChild(closeDiv);
        ov.appendChild(m); document.body.appendChild(ov);
        try{ m.classList.add('open'); ov.classList.add('open'); }catch(e){}
        if(!db){ tbody.innerHTML = '<tr><td colspan="6">Le service Classement n\'est pas configur√©. Ajoutez la configuration Firebase dans index.html.</td></tr>'; return; }
        let unsubGlobal = null, unsubWeek = null;
        function renderRow(d, rank){
          const tr = document.createElement('tr');
          const tdRank = document.createElement('td'); tdRank.textContent = String(rank);
          const tdPseudo = document.createElement('td'); tdPseudo.textContent = d.Pseudo || '';
          const tdNiv = document.createElement('td'); tdNiv.textContent = d['Niveau'] || d['Niveau Pr√©pa'] || '';
          const tdScore = document.createElement('td'); tdScore.textContent = d.Score_MPSI || d.Score_MPSI || 0;
          const tdBadges = document.createElement('td'); tdBadges.style.display='flex'; tdBadges.style.gap='6px';
          try{
            const t = d.Titres || d.titres || [];
            try{
              // take only titres with tier>0, sort by tier desc, show top 3
              if(Array.isArray(t) && t.length){
                const sorted = t.filter(x=> (x && Number(x.tier||0) > 0)).sort((a,b)=> Number(b.tier||0) - Number(a.tier||0)).slice(0,3);
                sorted.forEach(obj=>{
                  const name = obj.nom || obj.name || '';
                  const tier = obj.tier || 0;
                  const sp = document.createElement('span'); sp.className='badge-chip'; sp.textContent = name + ' ' + tierToRoman(tier);
                  sp.style.fontSize='0.8rem'; sp.style.padding='4px 6px'; sp.style.borderRadius='6px'; sp.style.background='rgba(0,0,0,0.04)'; tdBadges.appendChild(sp);
                });
              } else {
                const b = d.Badges || [];
                b.forEach(bn=>{ const sp = document.createElement('span'); sp.className='badge-chip'; sp.textContent = bn; sp.style.fontSize='0.8rem'; sp.style.padding='4px 6px'; sp.style.borderRadius='6px'; sp.style.background='rgba(0,0,0,0.04)'; tdBadges.appendChild(sp); });
              }
            }catch(e){}
          }catch(e){}
          const tdCartes = document.createElement('td'); tdCartes.textContent = d['Cartes r√©vis√©es'] || 0;
          tr.appendChild(tdRank); tr.appendChild(tdPseudo); tr.appendChild(tdNiv); tr.appendChild(tdBadges); tr.appendChild(tdScore); tr.appendChild(tdCartes);
          return tr;
        }

        function attachGlobal(){
          if(unsubGlobal) return;
          const qg = db.collection('Classement').orderBy('Score_MPSI','desc');
          unsubGlobal = qg.onSnapshot(snapshot=>{
            try{ tbody.innerHTML=''; let r=1; snapshot.forEach(doc=>{ const d=doc.data()||{}; tbody.appendChild(renderRow(d, r++)); }); }catch(e){ console.warn('leaderboard render', e); }
          }, err=>{ console.warn('leaderboard snapshot error', err); tbody.innerHTML = '<tr><td colspan="8">Erreur lecture du classement</td></tr>'; });
        }

        function attachWeek(){
          if(unsubWeek) return;
          const m = getMonthId();
          const qw = db.collection('Classement').where('Mois_ID','==', m).orderBy('Score_MPSI_mois','desc');
          unsubWeek = qw.onSnapshot(snapshot=>{
            try{ tbody.innerHTML=''; let r=1; snapshot.forEach(doc=>{ const d=doc.data()||{}; tbody.appendChild(renderRow(d, r++)); }); }catch(e){ console.warn('leaderboard render', e); }
          }, err=>{ console.warn('leaderboard snapshot error', err); tbody.innerHTML = '<tr><td colspan="6">Erreur lecture du classement</td></tr>'; });
        }

        tabGlobal.addEventListener('click', ()=>{ try{ if(unsubWeek){ unsubWeek(); unsubWeek = null; } if(!unsubGlobal) attachGlobal(); tabGlobal.disabled=true; tabWeek.disabled=false; }catch(e){} });
        tabWeek.addEventListener('click', ()=>{ try{ if(unsubGlobal){ unsubGlobal(); unsubGlobal = null; } if(!unsubWeek) attachWeek(); tabWeek.disabled=true; tabGlobal.disabled=false; }catch(e){} });
        // start on global
        tabGlobal.disabled = true; attachGlobal();
        // ensure listeners removed when overlay removed
        ov.addEventListener('remove', ()=>{ try{ if(unsubGlobal) unsubGlobal(); if(unsubWeek) unsubWeek(); }catch(e){} });
      }catch(e){ console.warn('showLeaderboardPopup', e); }
    }

    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min }

    // Titles popup: show all Titres and Objectifs computed locally
    function showTitlesPopup(){
      try{
        if(document.getElementById('titlesOverlay')) return;
        const stats = getProfileStats();
        const computed = (typeof computeTitles === 'function') ? computeTitles(stats) : {titres:[], objectifs:[]};
        const ov = document.createElement('div'); ov.id='titlesOverlay'; ov.className='modal-overlay'; ov.style.display='flex'; ov.style.alignItems='center'; ov.style.justifyContent='center'; ov.style.zIndex='2300';
        const m = document.createElement('div'); m.className='modal'; m.style.maxWidth='640px'; m.style.width='94%';
        const h = document.createElement('h3'); h.textContent = 'Titres obtenus'; m.appendChild(h);
        const list = document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='8px';
        // Titres
        const tbox = document.createElement('div'); tbox.style.marginTop='6px';
        // definitions for titles: thresholds and descriptions
        const defs = {
          'Gauss': {th:[100,300,600,1000,2000], desc:'Nombre total de bonnes r√©ponses.' , metric: ()=> Number(localStorage.getItem('fabanki:good_total')||0) },
          'Fourier': {th:[200,600,1200,2500,5000], desc:'Cartes r√©vis√©es au total.', metric: ()=> Number(stats.totalReviewed||0) },
          'Euler': {th:[75,80,85,90,92], desc:'Pourcentage de bonnes r√©ponses (sur un grand √©chantillon).', metric: ()=>{ const tot = Number(stats.totalReviewed||0); const good=Number(localStorage.getItem('fabanki:good_total')||0); return tot>0? Math.round((good/tot)*100):0 } },
          'Newton': {th:[20,50,100,200,365], desc:'S√©quence de cartes cons√©cutives sans "Rat√©" (cartes correctes d\'affil√©e).', metric: ()=> Number(localStorage.getItem('fabanki:consec_correct_max')||0) },
          'Maxwell': {th:[3,7,21,60,120], desc:'Jours cons√©cutifs d\'activit√©.', metric: ()=> Number(localStorage.getItem('fabanki:streak_current')||0) },
          'Noether': {th:[50,150,400,1000,3000], desc:'Cartes r√©vis√©es sans "Passer".', metric: ()=> Number(localStorage.getItem('fabanki:consec_no_pass_max')||0) },
          'Hadamard': {th:[50,150,400,1000,3000], desc:'Cartes √† r√©ponses longues (>20s)', metric: ()=> Number(localStorage.getItem('fabanki:long_answer_total')||0) }
        };
        if(computed.titres && computed.titres.length){
          computed.titres.forEach(t=>{
            const def = defs[t.nom] || null;
            const row = document.createElement('div'); row.style.display='flex'; row.style.flexDirection='column'; row.style.gap='6px'; row.style.padding='8px'; row.style.borderBottom='1px solid rgba(0,0,0,0.04)';
            const top = document.createElement('div'); top.style.display='flex'; top.style.justifyContent='space-between'; top.style.alignItems='center';
            const left = document.createElement('div'); left.style.fontWeight='700'; left.textContent = t.nom || '';
            const right = document.createElement('div'); right.className='muted small'; right.textContent = 'Tier ' + tierToRoman(t.tier || 0);
            top.appendChild(left); top.appendChild(right);
            row.appendChild(top);
            // description
            const desc = document.createElement('div'); desc.className='muted small'; desc.textContent = def? def.desc : '';
            row.appendChild(desc);
            // progress bar -> show progress toward NEXT tier; if at max tier, show 'Niveau max atteint'
            if(def){
              const cur = def.metric();
              const th = def.th;
              const curTier = Number(t.tier || 0);
              const maxTier = th.length;
              const barWrap = document.createElement('div'); barWrap.style.display='flex'; barWrap.style.alignItems='center'; barWrap.style.gap='8px';
              if(curTier >= maxTier){
                const done = document.createElement('div'); done.className='muted small'; done.textContent = 'Niveau max atteint';
                barWrap.appendChild(done);
              } else {
                const prevThreshold = curTier > 0 ? th[curTier-1] : 0;
                const nextThreshold = th[curTier];
                const progress = nextThreshold > prevThreshold ? Math.min(100, Math.max(0, Math.round((cur - prevThreshold) / (nextThreshold - prevThreshold) * 100))) : 100;
                const bar = document.createElement('div'); bar.style.flex='1'; bar.style.height='10px'; bar.style.background='#eee'; bar.style.borderRadius='6px';
                const fill = document.createElement('div'); fill.style.height='100%'; fill.style.width = progress + '%'; fill.style.background = getLevelColor(Math.min(50, Math.max(1, curTier+1))); fill.style.borderRadius='6px'; bar.appendChild(fill);
                const label = document.createElement('div'); label.className='muted small'; label.style.minWidth='140px';
                if(typeof def.metric === 'function' && t.nom === 'Euler'){
                  // For Euler, show percentage and how many additional good answers are needed for next threshold
                  const tot = Number(stats.totalReviewed||0);
                  const good = Number(localStorage.getItem('fabanki:good_total')||0);
                  const pct = cur;
                  if(tot <= 0){ label.textContent = `${pct}%`; }
                  else if(curTier >= maxTier){ label.textContent = `${pct}%`; }
                  else {
                    const targetPct = Number(nextThreshold) / 100;
                    const needed = Math.max(0, Math.ceil((targetPct * tot - good) / (1 - targetPct)));
                    label.textContent = `${pct}% ‚Äî il faut ${needed} bonnes r√©ponses suppl√©mentaires`;
                  }
                } else {
                  label.textContent = `${cur} / ${nextThreshold}`;
                }
                barWrap.appendChild(bar); barWrap.appendChild(label);
              }
              row.appendChild(barWrap);
            }
            tbox.appendChild(row);
          });
        } else { const none = document.createElement('div'); none.className='muted small'; none.textContent='Aucun titre d√©bloqu√© pour le moment.'; tbox.appendChild(none); }
        list.appendChild(tbox);

        // Objectifs
        const obox = document.createElement('div'); obox.style.marginTop='12px';
        const oh = document.createElement('h4'); oh.textContent='Objectifs sp√©ciaux'; obox.appendChild(oh);
        if(computed.objectifs && computed.objectifs.length){
          computed.objectifs.forEach(o=>{ const d = document.createElement('div'); d.textContent = o; obox.appendChild(d); });
        } else { const none = document.createElement('div'); none.className='muted small'; none.textContent='Aucun objectif sp√©cial atteint.'; obox.appendChild(none); }
        list.appendChild(obox);

        m.appendChild(list);
        const closeDiv = document.createElement('div'); closeDiv.style.display='flex'; closeDiv.style.justifyContent='flex-end'; closeDiv.style.marginTop='12px';
        const cb = document.createElement('button'); cb.className='secondary'; cb.textContent='Fermer'; cb.addEventListener('click', ()=>{ ov.remove(); }); closeDiv.appendChild(cb); m.appendChild(closeDiv);
        ov.appendChild(m); document.body.appendChild(ov);
        try{ ov.classList.add('open'); m.classList.add('open'); ov.setAttribute('aria-hidden','false'); }catch(e){}
        ov.addEventListener('click', (ev)=>{ if(ev.target === ov) ov.remove(); });
      }catch(e){ console.warn('showTitlesPopup', e); }
    }

    function computeXpForQuality(section, quality, timeSec, prevReviewHours){
      // quality: 3=Difficile,4=Bon,5=Facile ; timeSec adjusts slightly
      let low=0, high=0, penalty=0;
      if(section === 'maths' || section === 'physique'){
        if(quality===3){ low=7; high=10 } else if(quality===4){ low=10; high=15 } else if(quality===5){ low=12; high=20 } else return 0;
        penalty = -5;
      } else if(section === 'si' || section === 'info'){
        if(quality===3){ low=5; high=8 } else if(quality===4){ low=8; high=12 } else if(quality===5){ low=10; high=15 } else return 0;
        penalty = -3;
      } else if(section === 'anglais' || section === 'francais'){
        if(quality===3){ low=3; high=5 } else if(quality===4){ low=5; high=8 } else if(quality===5){ low=8; high=12 } else return 0;
        penalty = -2;
      } else {
        // default small gains
        if(quality===3){ low=3; high=6 } else if(quality===4){ low=5; high=8 } else if(quality===5){ low=8; high=10 } else return 0;
        penalty = -2;
      }
      const base = randInt(low, high);
      // time factor: short <5s -> 0.8, 5-20s ->1, >20s ->1.2
      let factor = 1;
      if(timeSec < 5) factor = 0.8; else if(timeSec > 20) factor = 1.2;
      // previous-review multiplier: old reviews give more XP
      let prevMult = 1;
      try{
        if(prevReviewHours === null || prevReviewHours === undefined) prevMult = 0.9; // new card
        else if(prevReviewHours >= 24*7) prevMult = 1.4; // long time
        else if(prevReviewHours >= 24) prevMult = 1.15;
        else if(prevReviewHours >= 12) prevMult = 1.05;
        else prevMult = 1;
      }catch(e){ prevMult = 1 }
      return Math.max(0, Math.round(base * factor * prevMult));
    }

    function computePenaltyForSection(section){ if(section==='maths' || section==='physique') return -5; if(section==='si' || section==='info') return -3; if(section==='anglais' || section==='francais') return -2; return -2 }

    // Level / XP helpers
    function xpForLevel(level){
      // exponential growth per level: base * mult^(level-1)
      const base = 50; const mult = 1.1;
      return Math.floor(base * Math.pow(mult, Math.max(0, level-1)));
    }

    function computeLevelAndProgress(totalXp){
      // returns { level, progress, need, toNext, pct }
      let remaining = Math.max(0, Math.floor(totalXp || 0));
      let level = 1;
      while(true){
        const need = xpForLevel(level);
        if(remaining < need){
          const progress = remaining;
          const toNext = need - remaining;
          const pct = need>0 ? (progress / need * 100) : 100;
          return { level, progress, need, toNext, pct };
        }
        remaining -= need;
        level++;
        // safety cap
        if(level > 200) return { level:200, progress:0, need: xpForLevel(200), toNext: xpForLevel(200), pct:0 };
      }
    }

    function getLevelColor(level){
      // grade colors by level ranges
       if(level < 3) return '#c70d00'; // dark-red
      if(level < 5) return '#eb4034'; // red
      if(level < 10) return '#ff771c'; // orange-red
      if(level < 15) return '#d1c70f'; // yellow
      if(level < 20) return '#7bc30f'; // lime-green
      if(level < 30) return '#0fa3b1'; // teal
      if(level < 40) return '#0f7ad1'; // blue
      if(level < 50) return '#263af0'; // indigo
      return '#9b5cff'; // purple
    }

    // show a centered level-up notification
    function showLevelUpNotification(newLevel, oldLevel){
      try{
        const id = 'levelUpNotify';
        if(document.getElementById(id)) document.getElementById(id).remove();
        const ov = document.createElement('div'); ov.id = id; ov.className = 'level-up-notify';
        const icon = document.createElement('div'); icon.style.fontSize='22px'; icon.textContent = '‚ú®'; icon.style.marginBottom='6px'; icon.style.textAlign='center';
        const h = document.createElement('div'); h.style.fontWeight='700'; h.style.fontSize='1.05rem'; h.style.textAlign='center'; h.textContent = `Niveau ${newLevel} !`;
        const sub = document.createElement('div'); sub.className='muted small'; sub.style.textAlign='center'; sub.textContent = oldLevel? `F√©licitations ‚Äî vous √™tes pass√© de ${oldLevel} √† ${newLevel}` : `Nouveau niveau : ${newLevel}`;
        ov.appendChild(icon); ov.appendChild(h); ov.appendChild(sub);
        document.body.appendChild(ov);
        // animate in
        requestAnimationFrame(()=> ov.classList.add('show'));
        // remove after a short display, animate out first
        setTimeout(()=>{
          try{ ov.classList.remove('show'); setTimeout(()=>{ try{ ov.remove(); }catch(e){} }, 360); }catch(e){}
        }, 4200);
      }catch(e){ console.warn('levelUpNotify', e); }
    }

    // show a small centered title-up notification (toast)
    function showTitleUpNotification(name, newTier, oldTier){
      try{
        const id = 'titleUpNotify-'+name.replace(/\s+/g,'_');
        if(document.getElementById(id)) document.getElementById(id).remove();
        const ov = document.createElement('div'); ov.id = id; ov.className = 'title-up-notify';
        const icon = document.createElement('div'); icon.style.fontSize='18px'; icon.textContent = 'üèÖ'; icon.style.marginBottom='6px'; icon.style.textAlign='center';
        const h = document.createElement('div'); h.style.fontWeight='700'; h.style.fontSize='0.98rem'; h.style.textAlign='center'; h.textContent = `${name} ${tierToRoman(newTier)}`;
        const sub = document.createElement('div'); sub.className='muted small'; sub.style.textAlign='center'; sub.textContent = oldTier? `Am√©lioration : ${tierToRoman(oldTier)} ‚Üí ${tierToRoman(newTier)}` : `Titre d√©bloqu√© : ${tierToRoman(newTier)}`;
        ov.appendChild(icon); ov.appendChild(h); ov.appendChild(sub);
        document.body.appendChild(ov);
        requestAnimationFrame(()=> ov.classList.add('show'));
        setTimeout(()=>{ try{ ov.classList.remove('show'); setTimeout(()=>{ try{ ov.remove(); }catch(e){} }, 360); }catch(e){} }, 3800);
      }catch(e){ console.warn('titleUpNotify', e); }
    }

    // create transient XP badge on main card
    function showXpToast(delta){
      try{
        if(!delta) return;
        const card = document.querySelector('.card#cardArea') || document.querySelector('.card');
        if(!card) return;
        const t = document.createElement('div');
        t.className = 'xp-toast';
        // position via CSS inline for placement but animation via classes
        t.style.position = 'absolute'; t.style.right = '14px'; t.style.top = '14px'; t.style.zIndex = '1500';
        if(delta>0){ t.style.background = 'rgba(30,160,80,0.12)'; t.style.color = 'green'; t.textContent = `+${delta} XP`; }
        else { t.style.background = 'rgba(255,80,80,0.08)'; t.style.color = 'crimson'; t.textContent = `${delta} XP`; }
        card.style.position = card.style.position || 'relative'; card.appendChild(t);
        // animate in
        requestAnimationFrame(()=> t.classList.add('show'));
        // animate out and remove
        setTimeout(()=>{
          try{ t.classList.add('leave'); t.classList.remove('show'); setTimeout(()=>{ try{ t.remove(); }catch(e){} }, 320); }catch(e){}
        }, 1800);
      }catch(e){}
    }
    // Render welcome decks view when no deck is loaded
    async function removeWelcome(){
      try{
        const w = document.getElementById('welcomeDecks'); if(w) w.remove();
        const mainEl = document.querySelector('main'); if(mainEl) mainEl.style.display='block';
        const stats = document.getElementById('stats'); if(stats) stats.style.display='block';
        const hint = document.getElementById('histHint'); if(hint) { hint.style.display='block'; hint.style.position=''; hint.style.marginBottom=''; }
        // restore body scrolling to previous behavior (desktop: hidden, mobile: default)
        try{ document.body.style.overflowY = (window.innerWidth >= 641) ? 'hidden' : ''; }catch(e){}
      }catch(e){}
    }

    async function renderWelcomeDecks(){
      try{
        // remove any existing welcome first
        await removeWelcome();
        updateStatus("Bienvenue sur Fab'Anki");
        // hide existing main/stats but keep DOM so handlers remain
        const mainEl = document.querySelector('main'); if(!mainEl) return;
        mainEl.style.display = 'none';
        const stats = document.getElementById('stats'); if(stats) stats.style.display='none';
        const hint = document.getElementById('histHint');
        const container = document.createElement('div'); container.id = 'welcomeDecks'; container.style.padding = '18px';

        // allow vertical scrolling on welcome page
        try{ document.body.style.overflowY = 'auto'; }catch(e){}

        // Level summary card (above the decks list)
        try{
          // if a hint exists, clone it and place the clone above the level card so it's not overlaying
          try{
            if(hint){
              const clone = hint.cloneNode(true);
              clone.id = 'histHint_welcome';
              clone.style.position = 'static';
              clone.style.top = '';
              clone.style.left = '';
              clone.style.right = '';
              clone.style.zIndex = '';
              clone.style.marginBottom = '10px';
              container.appendChild(clone);
              // hide original to prevent overlap
              hint.style.display = 'none';
            }
          }catch(e){}
          const lvlStats = computeLevelAndProgress(getXpTotal());
          const levelCard = document.createElement('div'); levelCard.className = 'card level-summary'; levelCard.style.marginBottom = '12px';
          const lvlBox = document.createElement('div'); lvlBox.style.display='flex'; lvlBox.style.alignItems='center'; lvlBox.style.gap='12px';
          const circ = 2 * Math.PI * 28;
          const offset = Math.round(circ * (1 - Math.max(0, Math.min(100, lvlStats.pct))/100));
          const color = getLevelColor(lvlStats.level);
          const ringHtml = `<div class="level-ring" style="flex:0 0 64px"><svg viewBox=\"0 0 100 100\"><circle cx=\"50\" cy=\"50\" r=\"28\" stroke=\"#eee\" stroke-width=\"8\" fill=\"none\"></circle><circle class=\"ring-fill\" cx=\"50\" cy=\"50\" r=\"28\" stroke=\"${color}\" stroke-width=\"8\" fill=\"none\" stroke-linecap=\"round\" stroke-dasharray=\"${circ}\" stroke-dashoffset=\"${offset}\"></circle></svg><div class=\"level-num\">${lvlStats.level}</div></div>`;
          const info = document.createElement('div'); info.style.display='flex'; info.style.flexDirection='column';
          const t = document.createElement('div'); t.style.fontWeight='700'; t.textContent = `Level ${lvlStats.level}`;
          const s = document.createElement('div'); s.className='muted small'; s.textContent = `${lvlStats.progress}/${lvlStats.need} XP avant le prochain niveau`;
          info.appendChild(t); info.appendChild(s);
          lvlBox.innerHTML = ringHtml; lvlBox.appendChild(info); levelCard.appendChild(lvlBox);
          container.appendChild(levelCard);
        }catch(e){ /* ignore level rendering on welcome if error */ }

        const card = document.createElement('div'); card.className='card';
        const title = document.createElement('h2'); title.textContent = "Decks disponibles"; title.style.margin='6px 0 12px 0'; title.style.color='var(--muted)';
        card.appendChild(title);
        const list = document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='8px';
        // fetch deck list
        let entries = [];
        try{ entries = await fetchDirectory('./decks/'); }catch(e){ entries = []; }
        if(!entries || entries.length===0){ const msg = document.createElement('div'); msg.textContent='Aucun deck trouv√©'; card.appendChild(msg); container.appendChild(card); document.body.appendChild(container); return }
        // normalize to simple file list and limit based on viewport height
        const allFiles = (Array.isArray(entries) ? entries : []).filter(e=> typeof e === 'string' && e.toLowerCase().endsWith('.xml')).sort();
        // compute limit: desktop -> 10; mobile -> depends on available vertical space
        function computeWelcomeLimit(){
          try{
            if(window.innerWidth >= 641) return 10;
            const headerHeight = 66; // fixed header
            const reserved = headerHeight + 160; // approximate space for title and actions
            const rowH = 64; // estimated per-row height
            const avail = Math.max(200, window.innerHeight - reserved);
            const lim = Math.max(3, Math.floor(avail / rowH));
            return lim;
          }catch(e){ return 6 }
        }
        const limit = computeWelcomeLimit();
        const files = allFiles.slice(0, limit);
        // compute counts
        const rows = [];
        for(const f of files){
          const url = './decks/' + f;
          const name = decodeURIComponent(f.replace(/\+/g,'')).replace(/\.xml$/i,'');
          const cnt = await countDueNowForDeck(url);
          rows.push({name, url, cnt});
        }
        rows.sort((a,b)=> (b.cnt||0) - (a.cnt||0));
        // show total due count next to title in red
        try{ const totalDue = rows.reduce((s,x)=> s + (x.cnt||0), 0); title.innerHTML = `Decks disponibles <span style="color:#d9534f;margin-left:8px">(${totalDue} √† faire)</span>`; }catch(e){}
        for(const r of rows){
          const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.gap='8px';
          const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='12px';
          const nm = document.createElement('div'); nm.textContent = r.name; nm.style.fontWeight = '600';
          left.appendChild(nm);
          const act = document.createElement('div'); act.style.display='flex'; act.style.alignItems='center'; act.style.gap='8px';
          const badge = document.createElement('span'); badge.className='due-badge'; badge.innerHTML = `<div class="due-num">${r.cnt>0? r.cnt : ''}</div><div class="due-label" style="display:${r.cnt>0?'block':'none'}">√† faire</div>`;
          const b = document.createElement('button'); b.className='secondary';
          b.textContent = (window.innerWidth <= 640) ? 'üìÇ' : 'Charger';
          b.addEventListener('click', async ()=>{ await removeWelcome(); loadDeckFromURL(r.url); deckURL = r.url; });
          // mirror deck-browser layout: badge to the left of the Charger button
          act.appendChild(badge); act.appendChild(b);
          row.appendChild(left); row.appendChild(act); list.appendChild(row);
        }
        card.appendChild(list); container.appendChild(card);
        const host = document.querySelector('.app') || document.body;
        const footer = host.querySelector('footer') || document.querySelector('footer') || null;
        if(footer) host.insertBefore(container, footer);
        else host.appendChild(container);
      }catch(e){ updateStatus("Bienvenue sur Fab'Anki"); }
    }

    if(pdeck){ deckURL = pdeck; loadDeckFromURL(pdeck); }
    else { renderWelcomeDecks(); }
  });

  // Expose functions as required (so they're available globally)
  window.loadDeckFromURL = loadDeckFromURL;
  window.parseXMLDeck = parseXMLDeck;
  window.interpretSides = interpretSides;
  window.renderFront = renderFront;
  window.renderBack = renderBack;
  window.renderKaTeX = renderKaTeX;
  window.initFSRS = initFSRS;
  window.scheduleCard = scheduleCard;
  window.getDueCards = getDueCards;

  </script>
</body>
</html>
